Nikon R3D NE (.R3D) support was introduced in SDK 9.1.0 and works similar to NEV clips.
The following Nikon cameras support R3D NE recording: ZR. 

Most SDK features are supported, including GPU image processing, lower resolution decodes,
most IPP2 decode settings and audio.


Sample clips
-----------------------------------------------
* https://www.red.com/sample-r3d-files


Nikon R3D NE differences from RED R3D
-----------------------------------------------
* single .R3D file recorded per clip in the root of the mag
* each clip is consecutively named: DSC_0001.R3D, DSC_0002.R3D, etc.
	* NOTE: unlike RED R3D, these files are separate clips and should not be treated as a single one!
	* NOTE: see the IdentifyFile() API defined in R3DSDK.h when to group files into clips or not
* always decodes in IPP2 (ColorVersion3, see Clip::MinimumColorVersion() & Clip::DefaultColorVersion() APIs)
* clips can have high-speed playback/project rates of 100 or 120 fps
* timecode:
	* edge/run-record timecode is optional and if missing will default to 01:00:00:00
	* timecode can be drop-frame, i.e.: 01:00:00;00
	* timecode will run at playback/project rate, including 100 or 120 fps (3-digit frame numbers)
* different/higher ISO values may be set per default: 64, 8000, 10000, 16000, 20000 or 25600
	* Nikon ISO 1250 will be mapped to SDK ISO 1280 + small Exposure Adjust setting
* clips can have Floating Point Audio, see the section on this below
* RMD_REDCODE metadata is "R3D NE" and RMD_SENSOR_NAME is "NIKON"


SDK features unavailable with R3D NE
-----------------------------------------------
* GPU decode (decompression). GpuDecoder::DecodeSupportedForClip() will return DSUnsupportedClipFormat
* R3D trim & snapshot as well as camera streaming through R3DStream or R3DStream2 APIs
* IPP2 (ColorVersion3) FlashingPixelAdjustment & MasklineAdjust settings
* HDRx, Extended Highlights, Broadcast image processing pipe & IMU track
* RMD_CAMERA_ID, RMD_CAMERA_POSITION, RMD_CLIP_ID, RMD_REEL_ID*'s and frame guide metadata


Floating Point Audio
-----------------------------------------------
Starting with R3D NE clips audio can optionally be 32-bit float as well as 24-bit integer as before or
not be present. Floating point audio can have a much higher dynamic range compared to integer audio,
so ideally your application will request & process floating point audio directly. The R3D SDK does offer
conversion to integer audio if needed.

To detect if a clip has floating point audio, the metadata item RMD_AUDIO_FORMAT can be checked. This
returns 1 when the clip has floating point audio, or 0 if it has integer or no audio.
  
There are two ways to decode floating point audio in the R3D SDK:

  
[1 -- decode in float] 
  
The Clip class has 2 functions to decode the audio as float: DecodeFloatAudio() & DecodeFloatAudioBlock().
These return the floating point samples as-is, in Big Endian format.

The API Clip::GetFloatAudioPeakAmplitude() can be used to to get the maximum sample value / peak amplitude
that can be encountered per channel. It is possible the returned values could be slightly above what was
actually recorded, but it will never be higher. 

  
[2 -- decode in integer] 
  
When using the non-float DecodeAudio() & DecodeAudioBlock() APIs any floating point audio will have per-
channel gain applied. When a clip is loaded the SDK will calculate a default per-channel gain to apply
for this conversion to maximize the signal-to-noise ratio and avoid clipping.

Audio returned from this API will be Big Endian and 32-bit, not 24 like it would for native integer audio.
RMD_SAMPLE_SIZE metadata will return 32 for floating point audio clips, which is correct for both the
native float audio APIs as well as the ones converting to integer.
  
The default per-channel gain will be inversely proportional to the output of GetFloatAudioPeakAmplitude()
and can be retrieve with the GetFloatAudioDefaultConversionGain() API.
  
To set a custom gain to apply when doing the float to integer conversion there are two overloaded
versions of the DecodeAudio() & DecodeAudioBlock() APIs that take a 'channelGainDecibels' array argument.

For user control over the gain it is recommended to default to the values returned from the
GetFloatAudioDefaultConversionGain() API, potentially with a small negative offset, and limit the
range from -50 to +50 dB.

A gain value below -50 will mute the given channel and a value above what is returned by
GetFloatAudioDefaultConversionGain() will result in clipping. 

 
(c) 2008-2025 RED DIGITAL CINEMA. All rights reserved.
