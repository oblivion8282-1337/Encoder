/* -LICENSE-START-
 ** Copyright (c) 2019 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

#include "BlackmagicRawAPI.h"

#include <atomic>
#include <chrono>
#include <iostream>
#include <thread>
#include <array>
#include <cassert>
#include <mutex>

#ifdef NDEBUG
#	define VERIFY(condition) condition
#else
#	define VERIFY(condition) assert(SUCCEEDED(condition))
#endif

// This sample code shows the Manual Decoder pipeline of the the Blackmagic RAW SDK.
// The Manual Decoder splits the Decode and Process operations into two separate steps each with their own callbacks.
// It also gives you far greater control over how buffers are allocated and used, allowing you to optimise the API's performance based on your application's needs.
// This sample uses Flow 2 of the Manual Decoder, which makes use of (and requires!) GPU acceleration.
// If you wish to write an application that supports both GPU-accelerated and CPU-only paths, you'll need to support IBlackmagicRawManualDecoderFlow1 as well as IBlackmagicRawManualDecoderFlow2.
// Both ProcessClipManualFlow1 and ProcessClipManualFlow2 were written under the assumption that this would be a common case, and hence BufferManagerFlow1 and BufferManagerFlow2 have a similar interface.

static constexpr BlackmagicRawResourceFormat s_resourceFormat = blackmagicRawResourceFormatBGRAU8;

// We run three jobs in parallel, to ensure best performance while minimising memory footprint.  Frame n will be read from the disk while frame n-1 is being decoded on the CPU and frame n-2 is being processed on the GPU.
static constexpr int s_maxJobsInFlight = 3;
static std::atomic<int> s_jobsInFlight = {0};

class BufferManagerFlow2
{
public:
	BufferManagerFlow2(IBlackmagicRawResourceManager* resourceManager, IBlackmagicRawManualDecoderFlow2* manualDecoder, void* post3DLUTBufferGPU, void* context, void* commandQueue, BlackmagicRawResourceType gpuResourceType)
	: m_resourceManager(resourceManager)
	, m_manualDecoder(manualDecoder)
	, m_post3DLUTBufferGPU(post3DLUTBufferGPU)
	, m_context(context)
	, m_commandQueue(commandQueue)
	, m_gpuResourceType(gpuResourceType)
	{
	}
	
	~BufferManagerFlow2()
	{
		if (m_bitStream != nullptr)
		{
			VERIFY(m_resourceManager->ReleaseResource(nullptr, nullptr, m_bitStream, blackmagicRawResourceTypeBufferCPU));
		}
		
		if (m_frameState != nullptr)
		{
			VERIFY(m_resourceManager->ReleaseResource(nullptr, nullptr, m_frameState, blackmagicRawResourceTypeBufferCPU));
		}
		
		if (m_decodedBufferCPU != nullptr)
		{
			VERIFY(m_resourceManager->ReleaseResource(nullptr, nullptr, m_decodedBufferCPU, blackmagicRawResourceTypeBufferCPU));
		}
		
		if (m_decodedBufferGPU != nullptr)
		{
			VERIFY(m_resourceManager->ReleaseResource(m_context, m_commandQueue, m_decodedBufferGPU, m_gpuResourceType));
		}
		
		if (m_workingBuffer != nullptr)
		{
			VERIFY(m_resourceManager->ReleaseResource(m_context, m_commandQueue, m_workingBuffer, m_gpuResourceType));
		}
		
		if (m_processedBuffer != nullptr)
		{
			VERIFY(m_resourceManager->ReleaseResource(m_context, m_commandQueue, m_processedBuffer, m_gpuResourceType));
		}
	}
	
	void populateFrameStateBuffer(IBlackmagicRawFrame* frame)
	{
		uint32_t frameStateSizeBytes;
		VERIFY(m_manualDecoder->GetFrameStateSizeBytes(&frameStateSizeBytes));
		
		// Allocate the buffer if necessary
		if (frameStateSizeBytes > m_frameStateSizeBytes)
		{
			if (m_frameState != nullptr)
			{
				VERIFY(m_resourceManager->ReleaseResource(nullptr, nullptr, m_frameState, blackmagicRawResourceTypeBufferCPU));
			}
			
			VERIFY(m_resourceManager->CreateResource(nullptr, nullptr, frameStateSizeBytes, blackmagicRawResourceTypeBufferCPU, blackmagicRawResourceUsageReadCPUWriteCPU, &m_frameState));
			m_frameStateSizeBytes = frameStateSizeBytes;
		}
		
		// Populate the buffer
		VERIFY(m_manualDecoder->PopulateFrameStateBuffer(frame, nullptr, nullptr, m_frameState, frameStateSizeBytes));
	}
	
	void createReadJob(IBlackmagicRawClipEx* clipEx, uint64_t frameIndex, IBlackmagicRawJob** jobRead)
	{
		uint32_t bitStreamSizeBytes = 0;
		VERIFY(clipEx->GetBitStreamSizeBytes(frameIndex, &bitStreamSizeBytes));
		
		// Allocate the buffer if necessary
		if (bitStreamSizeBytes > m_bitStreamSizeBytes)
		{
			if (m_bitStream != nullptr)
			{
				VERIFY(m_resourceManager->ReleaseResource(nullptr, nullptr, m_bitStream, blackmagicRawResourceTypeBufferCPU));
			}
			
			VERIFY(m_resourceManager->CreateResource(nullptr, nullptr, bitStreamSizeBytes, blackmagicRawResourceTypeBufferCPU, blackmagicRawResourceUsageReadCPUWriteCPU, &m_bitStream));
			m_bitStreamSizeBytes = bitStreamSizeBytes;
		}
		
		// Create the job
		VERIFY(clipEx->CreateJobReadFrame(frameIndex, m_bitStream, bitStreamSizeBytes, jobRead));
	}
	
	void createDecodeJob(IBlackmagicRawJob** decodeJob)
	{
		uint32_t decodedBufferSizeBytes;
		VERIFY(m_manualDecoder->GetDecodedSizeBytes(m_frameState, &decodedBufferSizeBytes));
		
		// Allocate the buffers if necessary
		if (decodedBufferSizeBytes > m_decodedBufferSizeBytes)
		{
			if (m_decodedBufferCPU != nullptr)
			{
				VERIFY(m_resourceManager->ReleaseResource(nullptr, nullptr, m_decodedBufferCPU, blackmagicRawResourceTypeBufferCPU));
			}
			
			if (m_decodedBufferGPU != nullptr)
			{
				VERIFY(m_resourceManager->ReleaseResource(m_context, m_commandQueue, m_decodedBufferGPU, m_gpuResourceType));
			}

			VERIFY(m_resourceManager->CreateResource(nullptr, nullptr, decodedBufferSizeBytes, blackmagicRawResourceTypeBufferCPU, blackmagicRawResourceUsageReadCPUWriteCPU, &m_decodedBufferCPU));
			VERIFY(m_resourceManager->CreateResource(m_context, m_commandQueue, decodedBufferSizeBytes, m_gpuResourceType, blackmagicRawResourceUsageReadGPUWriteCPU, &m_decodedBufferGPU));
			
			m_decodedBufferSizeBytes = decodedBufferSizeBytes;
		}
		
		// Create the job
		VERIFY(m_manualDecoder->CreateJobDecode(m_frameState, m_bitStream, m_decodedBufferCPU, decodeJob));
	}
	
	void createProcessJob(IBlackmagicRawJob** processJob)
	{
		uint32_t processedBufferSizeBytes;
		VERIFY(m_manualDecoder->GetProcessedSizeBytes(m_frameState, &processedBufferSizeBytes));
		
		uint32_t workingBufferSizeBytes;
		VERIFY(m_manualDecoder->GetWorkingSizeBytes(m_frameState, &workingBufferSizeBytes));
		
		// Allocate the Working Buffer if necessary
		if (workingBufferSizeBytes > m_workingBufferSizeBytes)
		{
			if (m_workingBuffer != nullptr)
			{
				VERIFY(m_resourceManager->ReleaseResource(m_context, m_commandQueue, m_workingBuffer, m_gpuResourceType));
			}
			
			VERIFY(m_resourceManager->CreateResource(m_context, m_commandQueue, workingBufferSizeBytes, m_gpuResourceType, blackmagicRawResourceUsageReadGPUWriteGPU, &m_workingBuffer));
			m_workingBufferSizeBytes = workingBufferSizeBytes;
		}
		
		// Allocate the Processed Buffer if necessary
		if (processedBufferSizeBytes > m_processedBufferSizeBytes)
		{
			if (m_processedBuffer != nullptr)
			{
				VERIFY(m_resourceManager->ReleaseResource(nullptr, nullptr, m_processedBuffer, blackmagicRawResourceTypeBufferCPU));
			}
			
			VERIFY(m_resourceManager->CreateResource(m_context, m_commandQueue, processedBufferSizeBytes, m_gpuResourceType, blackmagicRawResourceUsageReadGPUWriteGPU, &m_processedBuffer));
			m_processedBufferSizeBytes = processedBufferSizeBytes;
		}
		
		// Copy the Decoded buffer from main memory to the GPU
		uint32_t decodedBufferSizeBytes;
		VERIFY(m_manualDecoder->GetDecodedSizeBytes(m_frameState, &decodedBufferSizeBytes));
		VERIFY(m_resourceManager->CopyResource(m_context, m_commandQueue, m_decodedBufferCPU, blackmagicRawResourceTypeBufferCPU, m_decodedBufferGPU, m_gpuResourceType, decodedBufferSizeBytes, true));

		// Create the job
		VERIFY(m_manualDecoder->CreateJobProcess(m_context, m_commandQueue, m_frameState, m_decodedBufferGPU, m_workingBuffer, m_processedBuffer, m_post3DLUTBufferGPU, processJob));
	}
	
private:
	IBlackmagicRawResourceManager*		m_resourceManager			= nullptr;
	IBlackmagicRawManualDecoderFlow2*	m_manualDecoder				= nullptr;
	void*								m_post3DLUTBufferGPU		= nullptr;
	void*								m_context					= nullptr;
	void*								m_commandQueue				= nullptr;
	BlackmagicRawResourceType			m_gpuResourceType			= blackmagicRawResourceTypeBufferCPU;
	
	uint32_t							m_bitStreamSizeBytes		= 0;
	void*								m_bitStream					= nullptr;
	
	uint32_t							m_frameStateSizeBytes		= 0;
	void*								m_frameState				= nullptr;
	
	uint32_t							m_decodedBufferSizeBytes	= 0;
	void*								m_decodedBufferCPU			= nullptr;
	void*								m_decodedBufferGPU			= nullptr;

	uint32_t							m_workingBufferSizeBytes	= 0;
	void*								m_workingBuffer				= nullptr;

	uint32_t							m_processedBufferSizeBytes	= 0;
	void*								m_processedBuffer			= nullptr;
};

struct UserData
{
	unsigned long long m_frameIndex;
	BufferManagerFlow2* m_bufferManager;
};

// Note that this class is identical to the class in the Flow 1 sample, with the exception of the type of Buffer Manager used.
class CameraCodecCallback : public IBlackmagicRawCallback
{
public:
	explicit CameraCodecCallback() = default;
	virtual ~CameraCodecCallback() = default;
	
	virtual void ReadComplete(IBlackmagicRawJob* readJob, HRESULT result, IBlackmagicRawFrame* frame)
	{
		UserData* userData = nullptr;
		VERIFY(readJob->GetUserData((void**)&userData));
		BufferManagerFlow2* bufferManager = userData->m_bufferManager;
		
		if (SUCCEEDED(result))
		{
			std::lock_guard<std::mutex> lock(m_mutex);
			std::cout << "Read frame index: " << userData->m_frameIndex << std::endl;
		}
		else
		{
			std::lock_guard<std::mutex> lock(m_mutex);
			std::cout << "Failed to read frame index: " << userData->m_frameIndex << std::endl;
			
			delete userData;
			s_jobsInFlight--;
			return;
		}
		
		// Set the Resource Format before populating the Frame State buffer
		VERIFY(frame->SetResourceFormat(s_resourceFormat));
		
		// Allocate and populate the Frame State Buffer
		bufferManager->populateFrameStateBuffer(frame);
		
		// Start the Decode job
		IBlackmagicRawJob* decodeJob = nullptr;
		bufferManager->createDecodeJob(&decodeJob);
		VERIFY(decodeJob->SetUserData(userData));
		VERIFY(decodeJob->Submit());
		
		// Release the job (The API holds a reference to the job, so this call is just transferring ownership)
		VERIFY(decodeJob->Release());
	}
	
	virtual void DecodeComplete(IBlackmagicRawJob* decodeJob, HRESULT result)
	{
		UserData* userData = nullptr;
		VERIFY(decodeJob->GetUserData((void**)&userData));
		BufferManagerFlow2* bufferManager = userData->m_bufferManager;
		
		if (SUCCEEDED(result))
		{
			std::lock_guard<std::mutex> lock(m_mutex);
			std::cout << "Decoded frame index: " << userData->m_frameIndex << std::endl;
		}
		else
		{
			std::lock_guard<std::mutex> lock(m_mutex);
			std::cout << "Failed to decode frame index: " << userData->m_frameIndex << std::endl;
			
			delete userData;
			s_jobsInFlight--;
			return;
		}
		
		// Start the Process job
		IBlackmagicRawJob* processJob = nullptr;
		bufferManager->createProcessJob(&processJob);
		VERIFY(processJob->SetUserData(userData));
		VERIFY(processJob->Submit());
		
		// Release the job (The API holds a reference to the job, so this call is just transferring ownership)
		VERIFY(processJob->Release());
	}
	
	virtual void ProcessComplete(IBlackmagicRawJob* processJob, HRESULT result, IBlackmagicRawProcessedImage*)
	{
		UserData* userData = nullptr;
		VERIFY(processJob->GetUserData((void**)&userData));
		
		if (SUCCEEDED(result))
		{
			std::lock_guard<std::mutex> lock(m_mutex);
			std::cout << "Processed frame index: " << userData->m_frameIndex << std::endl;
		}
		else
		{
			std::lock_guard<std::mutex> lock(m_mutex);
			std::cout << "Failed to process frame index: " << userData->m_frameIndex << std::endl;
		}
		
		delete userData;
		s_jobsInFlight--;
	}
	
	virtual void TrimProgress(IBlackmagicRawJob*, float) {}
	virtual void TrimComplete(IBlackmagicRawJob*, HRESULT) {}
	virtual void SidecarMetadataParseWarning(IBlackmagicRawClip*, const char*, uint32_t, const char*) {}
	virtual void SidecarMetadataParseError(IBlackmagicRawClip*, const char*, uint32_t, const char*) {}
	virtual void PreparePipelineComplete(void*, HRESULT) {}
	
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID*)
	{
		return E_NOTIMPL;
	}
	
	virtual ULONG STDMETHODCALLTYPE AddRef(void)
	{
		return 0;
	}
	
	virtual ULONG STDMETHODCALLTYPE Release(void)
	{
		return 0;
	}
	
private:
	std::mutex m_mutex;
};

HRESULT ProcessClipManual(CameraCodecCallback* callback, IBlackmagicRawClip* clip, IBlackmagicRawResourceManager* resourceManager, IBlackmagicRawManualDecoderFlow2* manualDecoder, IBlackmagicRawPipelineDevice* device)
{
    IBlackmagicRawClipProcessingAttributes* clipProcessingAttributes = nullptr;
    IBlackmagicRawPost3DLUT* clipPost3DLUT = nullptr;
	void* clipPost3DLUTBufferGPU = nullptr;
    IBlackmagicRawClipEx* clipEx = nullptr;
    uint64_t frameCount = 0;
	uint64_t frameIndex = 0;
	void* context = nullptr;
	void* commandQueue = nullptr;
	BlackmagicRawPipeline pipeline;
	BlackmagicRawResourceType gpuResourceType = blackmagicRawResourceTypeBufferCPU;
	
	// Query the pipeline, context and command queue from the pipeline device.
	VERIFY(device->GetPipeline(&pipeline, &context, &commandQueue));
	
	switch (pipeline)
	{
		case blackmagicRawPipelineCUDA:
			gpuResourceType = blackmagicRawResourceTypeBufferCUDA;
			break;
			
		case blackmagicRawPipelineOpenCL:
			gpuResourceType = blackmagicRawResourceTypeBufferOpenCL;
			break;
			
		case blackmagicRawPipelineMetal:
			gpuResourceType = blackmagicRawResourceTypeBufferMetal;
			break;
			
		default:
			std::cerr << "Failed to get BlackmagicRawResourceType!" << std::endl;
			return E_FAIL;
	}
	
	assert(gpuResourceType != blackmagicRawResourceTypeBufferCPU);
		
    VERIFY(clip->QueryInterface(IID_IBlackmagicRawClipEx, (void**)&clipEx));
    VERIFY(clip->QueryInterface(IID_IBlackmagicRawClipProcessingAttributes, (void**)&clipProcessingAttributes));
    VERIFY(clip->GetFrameCount(&frameCount));
    VERIFY(clipProcessingAttributes->GetPost3DLUT(&clipPost3DLUT));
    if (clipPost3DLUT != nullptr)
    {
		BlackmagicRawResourceType post3dLutResourceType;
        VERIFY(clipPost3DLUT->GetResourceGPU(context, commandQueue, &post3dLutResourceType, &clipPost3DLUTBufferGPU));
		
		assert(post3dLutResourceType == gpuResourceType);
    }
	
	// We re-use BufferManager objects to avoid reallocating buffers every frame.
	std::array<BufferManagerFlow2*, s_maxJobsInFlight> bufferManagerPool;
	for (int i = 0; i < bufferManagerPool.size(); i++)
	{
		bufferManagerPool[i] = new BufferManagerFlow2(resourceManager, manualDecoder, clipPost3DLUTBufferGPU, context, commandQueue, gpuResourceType);
	}

	while (frameIndex < frameCount)
    {
		// Spin while the pipeline is saturated
		if (s_jobsInFlight >= s_maxJobsInFlight)
		{
			std::this_thread::sleep_for(std::chrono::microseconds(100));
			continue;
		}
		
		BufferManagerFlow2* bufferManager = bufferManagerPool[frameIndex % s_maxJobsInFlight];
		
		IBlackmagicRawJob* jobRead;
		bufferManager->createReadJob(clipEx, frameIndex, &jobRead);
		
		// Allocate and populate the UserData struct
		UserData* userData = new UserData();
		userData->m_bufferManager = bufferManager;
		userData->m_frameIndex = frameIndex;
		VERIFY(jobRead->SetUserData(userData));
		
		// Start the Read job
		VERIFY(jobRead->Submit());
		s_jobsInFlight++;
		
		// Release the job (The API holds a reference to the job, so this call is just transferring ownership)
		VERIFY(jobRead->Release());
		
		frameIndex++;
	}
	
	// Wait for all jobs to be complete before cleaning up.
	while (s_jobsInFlight > 0)
	{
		std::this_thread::sleep_for(std::chrono::microseconds(100));
	}
	
	for (int i = 0; i < bufferManagerPool.size(); i++)
	{
		delete bufferManagerPool[i];
	}
	
	if (clipPost3DLUT != nullptr)
		clipPost3DLUT->Release();
	
	if (clipProcessingAttributes != nullptr)
		clipProcessingAttributes->Release();
	
	if (clipEx != nullptr)
		clipEx->Release();

    return S_OK;
}

int main(int argc, const char* argv[])
{
    if (argc > 2)
    {
        std::cerr << "Usage: " << argv[0] << " clipName.braw" << std::endl;
        return 1;
    }
    
	const char* clipName = nullptr;
	bool clipNameProvided = argc == 2;
	if (clipNameProvided)
	{
		clipName = argv[1];
	}
	else
	{
		clipName = "../../../Media/sample.braw";
	}
    
    HRESULT result = S_OK;
    
    IBlackmagicRawFactory* factory = nullptr;
    IBlackmagicRaw* codec = nullptr;
	IBlackmagicRawPipelineIterator *pipelineIterator = nullptr;
	IBlackmagicRawPipelineDeviceIterator* deviceIterator = nullptr;
	IBlackmagicRawPipelineDevice* device = nullptr;
	IBlackmagicRawConfiguration* configuration = nullptr;
	IBlackmagicRawConfigurationEx* configurationEx = nullptr;
	IBlackmagicRawResourceManager* resourceManager = nullptr;
	IBlackmagicRawManualDecoderFlow2* manualDecoder = nullptr;
	IBlackmagicRawClip* clip = nullptr;

    CameraCodecCallback callback;
    
    do
    {
		factory = CreateBlackmagicRawFactoryInstanceFromPath("../../Libraries/");
        if (factory == nullptr)
        {
            std::cerr << "Failed to create IBlackmagicRawFactory!" << std::endl;
            result = E_FAIL;
            break;
        }
        
		result = factory->CreatePipelineIterator(blackmagicRawInteropNone, &pipelineIterator);
		if (result != S_OK)
		{
			std::cerr << "Failed to create IBlackmagicRawPipelineIterator!" << std::endl;
			break;
		}
		
		// In this sample code, we just get the first device from the first pipeline and use that to process frames.
		// The iterator shows GPU pipelines first, and sorts devices in descending order by compute capability, so in most cases this is the device you'll want to use.
		// However, for some hardware configurations (such as when the CPU outperforms the GPU), this is not the most performant pipeline.
		BlackmagicRawPipeline pipeline;
		result = pipelineIterator->GetPipeline(&pipeline);
		if (result != S_OK)
		{
			std::cerr << "Failed to get default BlackmagicRawPipeline!" << std::endl;
			break;
		}
		
		// This sample code only contains supports the GPU-accelerated Flow 2, and hence won't run on systems without compatible hardware.
		if (pipeline == blackmagicRawPipelineCPU)
		{
			std::cerr << "No Compatible GPU pipeline supported by your system!" << std::endl;
			break;
		}
		
		result = factory->CreatePipelineDeviceIterator(pipeline, blackmagicRawInteropNone, &deviceIterator);
		if (result != S_OK)
		{
			std::cerr << "Failed to create IBlackmagicRawPipelineDeviceIterator!" << std::endl;
			break;
		}
		
		// It is important that the device is created before the codec, and released after the codec.
		// This is because the codec uses pointers to context/command queue objects that are managed by the device.
		result = deviceIterator->CreateDevice(&device);
		if (result != S_OK)
		{
			std::cerr << "Failed to create IBlackmagicRawPipelineDevice!" << std::endl;
			break;
		}

        result = factory->CreateCodec(&codec);
        if (result != S_OK)
        {
            std::cerr << "Failed to create IBlackmagicRaw!" << std::endl;
            break;
        }

		result = codec->QueryInterface(IID_IBlackmagicRawConfiguration, (void**)&configuration);
		if (result != S_OK)
		{
			std::cerr << "Failed to create IBlackmagicRawConfiguration!" << std::endl;
			break;
		}
		
		result = configuration->SetFromDevice(device);
		if (result != S_OK)
		{
			std::cerr << "Failed to set configuration from device!" << std::endl;
			break;
		}

        result = codec->QueryInterface(IID_IBlackmagicRawConfigurationEx, (void**)&configurationEx);
        if (result != S_OK)
        {
            std::cerr << "Failed to get IBlackmagicRawConfigurationEx!" << std::endl;
            break;
        }
        
        result = configurationEx->GetResourceManager(&resourceManager);
        if (result != S_OK)
        {
            std::cerr << "Failed to get IBlackmagicRawResourceManager!" << std::endl;
            break;
        }
        
        result = codec->QueryInterface(IID_IBlackmagicRawManualDecoderFlow2, (void**)&manualDecoder);
        if (result != S_OK)
        {
            std::cerr << "Failed to get IBlackmagicRaw!" << std::endl;
            break;
        }
        
        result = codec->OpenClip(clipName, &clip);
        if (result != S_OK)
        {
            std::cerr << "Failed to open IBlackmagicRawClip!" << std::endl;
            break;
        }
        
        result = codec->SetCallback(&callback);
        if (result != S_OK)
        {
            std::cerr << "Failed to set IBlackmagicRawCallback!" << std::endl;
            break;
        }
		
        result = ProcessClipManual(&callback, clip, resourceManager, manualDecoder, device);
        codec->FlushJobs();
        
    } while (0);
	
	if (clip != nullptr)
		clip->Release();

	if (manualDecoder != nullptr)
		manualDecoder->Release();

	if (resourceManager != nullptr)
		resourceManager->Release();

	if (configurationEx != nullptr)
		configurationEx->Release();

	if (configuration != nullptr)
		configuration->Release();

    if (codec != nullptr)
        codec->Release();

	// The codec object is not able to manage the lifetime of the context or command queue objects it uses, as it's possible that they were obtained directly from a compute API (such as CUDA).
	// To prevent the codec from potentially performing operations with a dangling context/command queue pointer, it's important we release the device AFTER the codec.
	if (device != nullptr)
		device->Release();

	if (deviceIterator != nullptr)
		deviceIterator->Release();

	if (pipelineIterator != nullptr)
		pipelineIterator->Release();
    
    if (factory != nullptr)
        factory->Release();
    
    return result;
}
