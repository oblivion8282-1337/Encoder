/* -LICENSE-START-
 ** Copyright (c) 2022 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */
#include "BlackmagicRawAPI.h"

#include "ImfRgbaFile.h"
#include "ImfFramesPerSecond.h"
#include "ImfStandardAttributes.h"

#include <iostream>
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <string>
#include <chrono>
#include <memory>
#include <atomic>
#include <mutex>
#include <condition_variable>
#include <iostream>
#include <filesystem>

#ifdef DEBUG
	#include <cassert>
	#define VERIFY(condition) assert(SUCCEEDED(condition))
#else
	#define VERIFY(condition) condition
#endif

struct ExrMetadata
{
	float		frameRate { 0.0f };
	uint32_t	iso { 0 };
	std::string	shutterValue;
	std::string	focalLength;
	std::string	aperture;
	std::string	timecode;
};

struct FrameDecode
{
	uint64_t						frameIndex { 0 };
	uint32_t						pixelBufferPixelCount { 0 };
	ExrMetadata						metadata;
	std::atomic<bool>				inUse { false };
	std::string						exrFilename;
	std::unique_ptr<Imf::Rgba[]>	pixels;

	void resizePixelBuffer(uint32_t width, uint32_t height)
	{
		uint32_t pixelCount = width * height;

		if ((pixelBufferPixelCount == 0) || (pixelCount > pixelBufferPixelCount))
		{
			pixels = std::make_unique<Imf::Rgba[]>(pixelCount);
			pixelBufferPixelCount = pixelCount;
		}
	}

	void clearPixelBuffer()
	{
		pixelBufferPixelCount = 0;
		pixels = nullptr;
	}
};

constexpr uint32_t kMaxdecodeFramesInFlight = 2;

static FrameDecode							s_decodeBuffers[kMaxdecodeFramesInFlight];
static const BlackmagicRawResourceFormat	s_resourceFormat = blackmagicRawResourceFormatRGBF32;
static BlackmagicRawResolutionScale			s_frameScale = blackmagicRawResolutionScaleFull;
static std::string							s_brawFolder;
static std::vector<std::string>				s_brawFiles;
static std::string						 	s_exrFolder;
static std::string						 	s_exrFilePrefix;
static bool									s_quiet = false;
static bool									s_decodeWithMetadata = false;
static Imf::Compression						s_compression = Imf::NO_COMPRESSION;
static int									s_feedbackLength = 0;
static bool									s_singleFrameOnly = false;
static uint64_t								s_singleFrameIndex = 0;
static uint32_t								s_filesTranscodedCount = 0;
static std::atomic<uint64_t>				s_framesDecodedCount(0);
static std::atomic<uint64_t>				s_framesMissingCount(0);
static std::atomic<uint32_t>				s_framesDecodingCount(0);
static std::atomic<bool>					s_framesDecodedOrErrorSignalled(false);
static std::condition_variable				s_frameDecodedOrErrorSignal;
static std::mutex							s_frameDecodedOrErrorSignalLock;
static std::mutex							s_errorsMutex;
static std::vector<std::string>				s_errors;
static std::atomic<bool>					s_error(false);

static void PrintUsage()
{
	std::cout << "usage: OpenEXRTranscode [-p prefix] [-r res] [-c comp] [-m] [-f frame] [-q] brawFile [exrFolder]" << std::endl;
	std::cout << "where:" << std::endl;
	std::cout << "  brawFile: input Blackmagic RAW file or folder containing Blackmagic RAW file(s)" << std::endl;
	std::cout << " exrFolder: folder to store generated exr files. Default is brawFile folder" << std::endl;
	std::cout << "        -p: prefix for exr files. Default is the filename of the corresponding Blackmagic RAW file" << std::endl;
	std::cout << "        -r: res is 1, 2, 4, 8 which correspond to full size (default), 1/2 size, 1/4 size and 1/8 size respectively" << std::endl;
	std::cout << "        -c: specify compression method for exr file. Default is none. -c ? will list compression choices" << std::endl;
	std::cout << "        -m: use clip metadata for decoding. Default is linear gamma and ACES AP0 gamut" << std::endl;
	std::cout << "        -f: frame is the zero based frame index for transcoding a single frame" << std::endl;
	std::cout << "        -q: is quiet mode where no feedback is displayed during transcoding" << std::endl;
	std::cout << "            -f and -p options are not valid if transcoding more then one Blackmagic RAW file" << std::endl;
}

static void PrintCompressionOptions()
{
	std::cout << "Compression Options" << std::endl;
	std::cout << "none   no compression." << std::endl;
	std::cout << "rle    run length encoding." << std::endl;
	std::cout << "zips   zlib compression, one scan line at a time." << std::endl;
	std::cout << "zip    zlib compression, in blocks of 16 scan lines." << std::endl;
	std::cout << "piz    piz-based wavelet compression." << std::endl;
	std::cout << "pxr24  lossy 24-bit float compression." << std::endl;
	std::cout << "b44    lossy 4-by-4 pixel block compression," << std::endl;
	std::cout << "       fixed compression rate." << std::endl;
	std::cout << "b44a   lossy 4-by-4 pixel block compression," << std::endl;
	std::cout << "       flat fields are compressed more." << std::endl;
	std::cout << "dwaa   lossy DCT based compression, in blocks of 32 scanlines." << std::endl;
	std::cout << "       More efficient for partial buffer access." << std::endl;
	std::cout << "dwab   lossy DCT based compression, in blocks of 256 scanlines." << std::endl;
	std::cout << "       More efficient space wise and faster to decode full frames" << std::endl;
	std::cout << "       than dwaa compression." << std::endl;
}

static void ClearErrors()
{
	std::lock_guard<std::mutex> lock(s_errorsMutex);

	s_errors.clear();
	s_error = false;
}

static void SetError(const char* message)
{
	std::lock_guard<std::mutex> lock(s_errorsMutex);

	s_errors.push_back(message);
	s_error = true;
}

static void PrintErrors()
{
   std::lock_guard<std::mutex> lock(s_errorsMutex);

   for (const auto& message : s_errors)
	   printf("Error: %s\n", message.c_str());
	if (! s_errors.empty())
		printf("\n");
}

static bool ExrTimecodeFromString(const std::string& timecodeString, Imf::TimeCode& timecode)
{
	if (timecodeString.length() != 11)
		return false;

	try
	{
		int hours = 0, mins = 0, secs = 0, frames = 0;

		if (sscanf(timecodeString.c_str(), "%02d:%02d:%02d:%02d", &hours, &mins, &secs, &frames) != 4)
			return false;

		timecode.setHours(hours);
		timecode.setMinutes(mins);
		timecode.setSeconds(secs);
		timecode.setFrame(frames);
	}
	catch (const std::exception& ex)
	{
		return false;
	}

	return true;
}

static bool ExrFocusFromString(const std::string& focusString, float& focus)
{
	size_t len = focusString.length();

	if (len < 3)
		return false;

	bool endsWithmm = (focusString[len-1] == 'm') && (focusString[len-2] == 'm');
	if (! endsWithmm)
		return false;

	char* endc;

	focus = std::strtof(focusString.c_str(), &endc) /1000.0f;
	if (*endc != 'm')
		return false;

	return true;
}

static bool ExrApertureFromString(const std::string& apertureString, float& focus)
{
	if (apertureString.length() == 0)
		return false;
	if (apertureString[0] != 'f')
		return false;

	char* endc;

	focus = std::strtof(apertureString.c_str() + 1, &endc);
	if (*endc != '\0')
		return false;

	return true;
}

static bool ExrExposureFromString(const std::string& shutterValue, float frameRate, float& exposure)
{
	if (shutterValue.length() == 0)
		return false;
	if (frameRate == 0.0f)
		return false;

	char* endc;

	float angle = std::strtof(shutterValue.c_str(), &endc);

	if (*endc != '\xc2')
		return false;
	if (angle == 0.0f)
		return false;

	exposure = angle / (frameRate * 360.0f);

	return true;
}

static HRESULT WriteFrame(FrameDecode* decode, uint32_t width, uint32_t height, const float* pixelData)
{
	uint32_t pixelCount = width * height;

	decode->resizePixelBuffer(width, height);
	for (uint32_t i = 0; i < pixelCount; i++)
	{
		decode->pixels[i] = { pixelData[0], pixelData[1], pixelData[2], 1.0f };
		pixelData += 3;
	}

	try
	{
		float pixelAspectRatio = 1.0f;
		const IMATH_NAMESPACE::V2f screenWindowCenter = IMATH_NAMESPACE::V2f (0, 0);
		float screenWindowWidth = 1.0f;
		Imf::LineOrder lineOrder = Imf::INCREASING_Y;
		Imf::Header header(width, height, pixelAspectRatio, screenWindowCenter, screenWindowWidth, lineOrder, s_compression);
		Imf::TimeCode timecode;
		float focus;
		float aperture;
		float exposure;

		if (ExrTimecodeFromString(decode->metadata.timecode, timecode))
			Imf::addTimeCode(header, timecode);
		Imf::addFramesPerSecond(header, Imf::guessExactFps(decode->metadata.frameRate));
		if (ExrExposureFromString(decode->metadata.shutterValue, decode->metadata.frameRate, exposure))
			Imf::addExpTime(header, exposure);
		Imf::addIsoSpeed(header, decode->metadata.iso);
		if (ExrApertureFromString(decode->metadata.aperture, aperture))
			Imf::addAperture(header, aperture);
		if (ExrFocusFromString(decode->metadata.focalLength, focus))
			Imf::addFocus(header, focus);

		Imf::RgbaOutputFile file(decode->exrFilename.c_str(), header);

		file.setFrameBuffer(decode->pixels.get(), 1, (int)width);
		file.writePixels((int)height);
	}
	catch (const std::exception& ex)
	{
		SetError("Failed to write OpenEXR file for frame");
		SetError(ex.what());
		return E_FAIL;
	}

	return S_OK;
}

static void SignalFrameDecodedOrError(FrameDecode* decode)
{
	decode->inUse = false;
	s_framesDecodingCount--;
	s_framesDecodedCount++;
	s_framesDecodedOrErrorSignalled = true;
	s_frameDecodedOrErrorSignal.notify_one();
}

static void WaitForFrameDecodedOrError()
{
	std::unique_lock<std::mutex> waitLock(s_frameDecodedOrErrorSignalLock);
	s_frameDecodedOrErrorSignal.wait(waitLock, []{ return s_framesDecodedOrErrorSignalled.load(); });
	s_framesDecodedOrErrorSignalled = false;
}

static void VariantToStdString(const Variant& value, std::string& stdString)
{
	stdString = "";
	if (value.vt != blackmagicRawVariantTypeString)
		stdString = value.bstrVal;
}

static HRESULT GetFrameMetadata(IBlackmagicRawFrame* frame, ExrMetadata& metadata)
{
	IBlackmagicRawFrameProcessingAttributes* frameProcessingAttributes = nullptr;
	Variant value;
	HRESULT result = S_OK;

	do
	{
		result = frame->QueryInterface(IID_IBlackmagicRawFrameProcessingAttributes, reinterpret_cast<void**>(&frameProcessingAttributes));
		if (FAILED(result))
		{
			SetError("Failed to get IBlackmagicRawFrameProcessingAttributes interface");
			break;
		}

		// Get iso
		VariantClear(&value);
		result = frameProcessingAttributes->GetFrameAttribute(blackmagicRawFrameProcessingAttributeISO, &value);
		if (FAILED(result))
			break;
		metadata.iso = value.uintVal;

		// Get timecode
		const char* timecode;

		result = frame->GetTimecode(&timecode);
		if (FAILED(result))
			break;
		metadata.timecode = timecode;
		free((void*)timecode);

		// Shutter Value
		VariantClear(&value);
		result = frame->GetMetadata("shutter_value", &value);
		if (FAILED(result))
			break;
		VariantToStdString(value, metadata.shutterValue);

		// Focal Length
		VariantClear(&value);
		result = frame->GetMetadata("focal_length", &value);
		if (FAILED(result))
			break;
		VariantToStdString(value, metadata.focalLength);

		// Aperture
		VariantClear(&value);
		result = frame->GetMetadata("aperture", &value);
		if (FAILED(result))
			break;
		VariantToStdString(value, metadata.aperture);

	} while (0);

	if (frameProcessingAttributes != nullptr)
		frameProcessingAttributes->Release();

	return result;
}

class CameraCodecCallback : public IBlackmagicRawCallback
{
public:
	explicit CameraCodecCallback() = default;
	virtual ~CameraCodecCallback() = default;

	virtual void ReadComplete(IBlackmagicRawJob* readJob, HRESULT result, IBlackmagicRawFrame* frame)
	{
		IBlackmagicRawJob* decodeAndProcessJob = nullptr;
		FrameDecode* decode = nullptr;

		VERIFY(readJob->GetUserData(reinterpret_cast<void**>(&decode)));

		// ignore dropped frame
		if (result == E_UNEXPECTED)
		{
			s_framesMissingCount++;
			SignalFrameDecodedOrError(decode);
			return;
		}

		if (SUCCEEDED(result))
			result = GetFrameMetadata(frame, decode->metadata);
		if (SUCCEEDED(result))
			result = frame->SetResourceFormat(s_resourceFormat);
		if (SUCCEEDED(result))
			result =  frame->SetResolutionScale(s_frameScale);
		if (SUCCEEDED(result))
			result = frame->CreateJobDecodeAndProcessFrame(nullptr, nullptr, &decodeAndProcessJob);
		if (SUCCEEDED(result))
		{
			decodeAndProcessJob->SetUserData(reinterpret_cast<void*>(decode));
			result = decodeAndProcessJob->Submit();
			decodeAndProcessJob->Release();
		}
		if (FAILED(result))
		{
			SetError("Decode read phase failed");
			SignalFrameDecodedOrError(decode);
		}
	}

	virtual void ProcessComplete(IBlackmagicRawJob* job, HRESULT result, IBlackmagicRawProcessedImage* processedImage)
	{
		uint32_t width = 0;
		uint32_t height = 0;
		void* imageData = nullptr;
		FrameDecode* decode = nullptr;

		VERIFY(job->GetUserData(reinterpret_cast<void**>(&decode)));
		if (SUCCEEDED(result))
			result = processedImage->GetWidth(&width);
		if (SUCCEEDED(result))
			result = processedImage->GetHeight(&height);
		if (SUCCEEDED(result))
			result = processedImage->GetResource(&imageData);
		if (SUCCEEDED(result))
			result = WriteFrame(decode, width, height, reinterpret_cast<float*>(imageData));
		if (FAILED(result))
			SetError("Decode processing phase failed");
		SignalFrameDecodedOrError(decode);
	}

	virtual void DecodeComplete(IBlackmagicRawJob*, HRESULT) {}
	virtual void TrimProgress(IBlackmagicRawJob*, float) {}
	virtual void TrimComplete(IBlackmagicRawJob*, HRESULT) {}

	virtual void SidecarMetadataParseWarning(IBlackmagicRawClip*, const char*, uint32_t, const char*) {}
	virtual void SidecarMetadataParseError(IBlackmagicRawClip*, const char*, uint32_t, const char*) {}
	virtual void PreparePipelineComplete(void*, HRESULT) {}

	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID*)
	{
		return E_NOTIMPL;
	}

	virtual ULONG STDMETHODCALLTYPE AddRef(void)
	{
		return 0;
	}

	virtual ULONG STDMETHODCALLTYPE Release(void)
	{
		return 0;
	}
};

static bool endsWith(const std::string& str, char endChar)
{
	return (! str.empty()) && (str.back() == endChar);
}

static std::string normalisePath(const std::string& pathString)
{
	if (pathString.empty())
		return pathString;

	std::string replacement(pathString);

	// Replace all backslashes with forward slashes
	std::replace(replacement.begin(), replacement.end(), '\\', '/');

	// If file begins with ./ then remove it
	if (replacement.substr(0, 2) == "./")
		replacement = replacement.substr(2);

	return replacement;
}

static FrameDecode* GetDecodeBuffer()
{
	FrameDecode* decode = nullptr;

	for (uint32_t i = 0; i < kMaxdecodeFramesInFlight; i++)
	{
		FrameDecode& decodeBuffer = s_decodeBuffers[i];

		if (! decodeBuffer.inUse)
		{
			decodeBuffer.inUse = true;
			decode = &s_decodeBuffers[i];
			break;
		}
	}

	return decode;
}

static HRESULT DecodeFrame(IBlackmagicRawClip* clip, const std::string& folder, const std::string& prefix, uint64_t frameIndex, const ExrMetadata& metadata)
{
	IBlackmagicRawJob* readJob = nullptr;
	FrameDecode* decode = GetDecodeBuffer();
	char buff[32];
	HRESULT result;

	if (decode == nullptr)
	{
		SetError("Failed to get decode buffer!");
		return E_FAIL;
	}
	decode->frameIndex = frameIndex;
	decode->metadata = metadata;
	sprintf(buff, "_%05lu.exr", frameIndex);
	decode->exrFilename = folder + prefix + buff;

	result = clip->CreateJobReadFrame(frameIndex, &readJob);
	if (FAILED(result))
	{
		SetError("Failed to create IBlackmagicRawJob!");

		return result;
	}

	// Use the IBlackmagicRawReadJobHints interface to set the reader resolution scale.
    COMPtr<IBlackmagicRawReadJobHints> readJobHints;
    verify(SUCCEEDED(readJob->QueryInterface(IID_IBlackmagicRawReadJobHints, &readJobHints)));
    readJobHints->SetReaderResolutionScale(s_frameScale);

	readJob->SetUserData(reinterpret_cast<void*>(decode));
	s_framesDecodingCount++;

	result = readJob->Submit();
	readJob->Release();
	if (FAILED(result))
	{
		SetError("Failed to submit IBlackmagicRawJob!");

		return result;
	}

	return S_OK;
}

static bool ProcessCommandLine(int argc, const char* argv[], bool& showCompressionOptions)
{
	bool argsValid = true;
	int ndx = 1;

	showCompressionOptions = false;

	// Must have at least one argument
	if (argc < 2)
		return false;

	// strip off and validate the options
	while ((ndx < argc) && (argv[ndx][0] == '-'))
	{
		const char* arg = argv[ndx];

		if (strlen(arg) != 2)
		{
			SetError("Missing option specifier");
			argsValid = false;
			break;
		}
		if (arg[1] == 'q')
		{
			s_quiet = true;
		}
		else if (arg[1] == 'm')
		{
			s_decodeWithMetadata = true;
		}
		else if (arg[1] == 'c')
		{
			ndx++;
			if (ndx >= argc)
			{
				SetError("No compression specified with -f option");
				argsValid = false;
			}
			else
			{
				bool compressionValid = true;

				arg = argv[ndx];
				if (! strcmp(arg, "?"))
					showCompressionOptions = true;
				else if (strcmp(arg, "piz") == 0)
					s_compression = Imf::PIZ_COMPRESSION;
				else if (strcmp(arg, "none") == 0)
					s_compression = Imf::NO_COMPRESSION;
				else if (strcmp(arg, "rle") == 0)
					s_compression = Imf::RLE_COMPRESSION;
				else if (strcmp(arg, "zips") == 0)
					s_compression = Imf::ZIPS_COMPRESSION;
				else if (strcmp(arg, "zip") == 0)
					s_compression = Imf::ZIP_COMPRESSION;
				else if (strcmp(arg, "pxr24") == 0)
					s_compression = Imf::PXR24_COMPRESSION;
				else if (strcmp(arg, "b44") == 0)
					s_compression = Imf::B44_COMPRESSION;
				else if (strcmp(arg, "b44a") == 0)
					s_compression = Imf::B44A_COMPRESSION;
				else if (strcmp(arg, "dwaa") == 0)
					s_compression = Imf::DWAA_COMPRESSION;
				else if (strcmp(arg, "dwab") == 0)
					s_compression = Imf::DWAB_COMPRESSION;
				else
					compressionValid = false;
				if (! compressionValid)
				{
					std::string msg;
					msg.append("Invalid compression method '");
					msg.append(arg);
					msg.append("' specified with -c option");
					SetError(msg.c_str());
					argsValid = false;
					break;
				}
			}
			if (! argsValid)
				break;
		}
		else if (arg[1] == 'f')
		{
			s_singleFrameOnly = true;
			ndx++;
			if (ndx >= argc)
			{
				SetError("No frame specified with -f option");
				argsValid = false;
			}
			else
			{
				char* endc;

				arg = argv[ndx];
				s_singleFrameIndex = std::strtol(arg, &endc, 10);
				if (*endc != '\0')
				{
					std::string msg;
					msg.append("Invalid frame index '");
					msg.append(arg);
					msg.append("' specified with -f option");
					SetError(msg.c_str());
					argsValid = false;
					break;
				}
			}
			if (! argsValid)
				break;
		}
		else if (arg[1] == 'p')
		{
			ndx++;
			if (ndx >= argc)
			{
				SetError("No prefix specified with -p option");
				argsValid = false;
			}
			else
			{
				s_exrFilePrefix = argv[ndx];
			}
			if (! argsValid)
				break;
		}

		else if (arg[1] == 'r')
		{
			ndx++;
			if (ndx >= argc)
			{
				SetError("No resolution specified with -r option");
				argsValid = false;
			}
			else
			{
				bool resValid = true;

				arg = argv[ndx];
				if (strlen(arg) != 1)
				{
					resValid = false;
				}
				else
				{
					if (arg[0] == '1')
						s_frameScale = blackmagicRawResolutionScaleFull;
					else if (arg[0] == '2')
						s_frameScale = blackmagicRawResolutionScaleHalf;
					else if (arg[0] == '4')
						s_frameScale = blackmagicRawResolutionScaleQuarter;
					else if (arg[0] == '8')
						s_frameScale = blackmagicRawResolutionScaleEighth;
					else
						resValid = false;
				}
				if (! resValid)
				{
					std::string msg;
					msg.append("Invalid resolution '");
					msg.append(arg);
					msg.append("' specified with -r option");
					SetError(msg.c_str());
					argsValid = false;
					break;
				}
			}
			if (! argsValid)
				break;
		}
		else
		{
			std::string msg;
			msg.append("Unknown command line argument '");
			msg.append(arg);
			msg.append("'");
			SetError(msg.c_str());
			argsValid = false;
			break;
		}
		ndx++;
	}
	if (! argsValid)
		return false;

	// There needs to two arguments left
	int nArgsLeft = argc - ndx;

	if (nArgsLeft > 2)
	{
		SetError("Invalid number of command line arguments");
		return false;
	}
	else if (nArgsLeft == 0)
	{
		SetError("Missing required Blackmagic RAW file/folder and exrFolder parameters");
		return false;
	}

	// Process brawfile argument
	std::string brawFile = normalisePath(std::string(argv[ndx]));
	std::error_code ec;
    
	ndx++;
	brawFile = std::filesystem::absolute(brawFile, ec);
	if (! std::filesystem::exists(brawFile, ec))
	{
		std::string msg;
		msg.append("Blackmagic RAW '");
		msg.append(brawFile);
		msg.append("' not found");
		SetError(msg.c_str());

		return false;
	}

	if (std::filesystem::is_directory(brawFile))
	{
		s_brawFolder = brawFile;
		if (! endsWith(s_brawFolder, '/'))
			s_brawFolder.append("/");
		for (const auto& entry : std::filesystem::directory_iterator(s_brawFolder))
		{
			if (entry.is_directory())
				continue;

			const std::filesystem::path path = entry.path();

			if (path.extension() == ".braw")
				s_brawFiles.push_back(path.filename());
		}
	}
	else
	{
		std::filesystem::path path = brawFile;

		s_brawFolder = path.parent_path();
		if (! endsWith(s_brawFolder, '/'))
			s_brawFolder.append("/");

		s_brawFiles.push_back(path.filename());
	}

	// There should be at least 1 braw file to transcode
	if (s_brawFiles.empty())
	{
		SetError("No Blackmagic RAW files found");

		return false;
	}

	// process exrfolder argument
	if (nArgsLeft == 1)
		s_exrFolder = s_brawFolder;
	else
	{
		std::string exrFolder = normalisePath(std::string(argv[ndx]));

		s_exrFolder = std::filesystem::absolute(exrFolder, ec);
		if (! std::filesystem::exists(s_exrFolder, ec))
		{
			if (! std::filesystem::create_directory(s_exrFolder, ec))
			{
				std::string msg;
				msg.append("exrfolder '");
				msg.append(s_exrFolder);
				msg.append("' is not valid");
				SetError(msg.c_str());

				return false;
			}
		}
	}
	if (! endsWith(s_exrFolder, '/'))
		s_exrFolder.append("/");

	// Check if any invalid combinations are specified
	if (s_brawFiles.size() > 1)
	{
		if (s_singleFrameOnly)
		{
			SetError("-f option may not be used when more than one input Blackmagic RAW file is specified");
			argsValid = false;
		}
		if (s_exrFilePrefix.length() > 0)
		{
			SetError("-p option may not be used when more than one input Blackmagic RAW file is specified");
			argsValid = false;
		}
		if (! argsValid)
			return false;
	}

	return true;
}

static void ClearFeedback()
{
	if (s_quiet)
		return;

	for (int i = 0; i < s_feedbackLength; i++)
		printf(" ");
	printf("\r");
	s_feedbackLength = 0;
}

static void ShowFeedbackProgress(const std::string& brawFilename, uint64_t frameCount)
{
	if (s_quiet)
		return;
	double percent = ((double)s_framesDecodedCount / (double)frameCount) * 100.0;
	int length = printf("Transcoding File: %4u of %4lu %s  %5.1f%% Frame %5lu of %5lu\r", s_filesTranscodedCount+1, s_brawFiles.size(), brawFilename.c_str(), percent, s_framesDecodedCount.load(), frameCount);

	if (length > s_feedbackLength)
		s_feedbackLength = length;
}

static void ShowFeedbackResult(const std::string& brawFilename, uint64_t frameCount)
{
	if (s_quiet)
		return;
	ClearFeedback();

	uint32_t percent = (uint32_t)(((double)s_framesDecodedCount / (double)frameCount) * 100.0);

	if (s_error)
	{
		printf("Transcoded  File: %4u of %4lu %s  %3u%% %s\n", s_filesTranscodedCount, s_brawFiles.size(), brawFilename.c_str(), percent, "FAIL");
	}
	else
	{
		if (s_framesMissingCount > 0)
			printf("Transcoded  File: %4u of %4lu %s  %3u%% - Done with %lu frames skipped\n", s_filesTranscodedCount, s_brawFiles.size(), brawFilename.c_str(), percent, s_framesMissingCount.load());
		else
			printf("Transcoded  File: %4u of %4lu %s  %3u%% OK\n", s_filesTranscodedCount, s_brawFiles.size(), brawFilename.c_str(), percent);
	}
}

static HRESULT SetDecodeOptions(IBlackmagicRawClip* clip)
{
	if (s_decodeWithMetadata)
		return S_OK;

	IBlackmagicRawClipProcessingAttributes*	clipProcessingAttributes = nullptr;
	Variant value;
	HRESULT result = S_OK;

	do
	{
		result = clip->QueryInterface(IID_IBlackmagicRawClipProcessingAttributes, reinterpret_cast<void**>(&clipProcessingAttributes));
		if (FAILED(result))
		{
			SetError("Failed to get IBlackmagicRawClipProcessingAttributes interface");
			break;
		}

		// Set gamma
		VariantInit(&value);
		value.vt = blackmagicRawVariantTypeString;
		value.bstrVal = "Linear";
		result = clipProcessingAttributes->SetClipAttribute(blackmagicRawClipProcessingAttributeGamma, &value);
		value.bstrVal = nullptr;
		if (FAILED(result))
		{
			SetError("Failed to set Linear gamma");
			break;
		}

		// Set gamut
		VariantInit(&value);
		value.vt = blackmagicRawVariantTypeString;
		value.bstrVal = "ACES AP0";
		result = clipProcessingAttributes->SetClipAttribute(blackmagicRawClipProcessingAttributeGamut, &value);
		value.bstrVal = nullptr;
		if (FAILED(result))
		{
			SetError("Failed to set ACES AP0 gamut");
			break;
		}

		// Set 3DLUT to disabled
		VariantInit(&value);
		value.vt = blackmagicRawVariantTypeString;
		value.bstrVal = "Disabled";
		result = clipProcessingAttributes->SetClipAttribute(blackmagicRawClipProcessingAttributePost3DLUTMode, &value);
		value.bstrVal = nullptr;
		if (FAILED(result))
		{
			SetError("Failed to set 3DLUT disabled");
			break;
		}

	} while (0);

	if (clipProcessingAttributes != nullptr)
		clipProcessingAttributes->Release();

	return result;
}

static HRESULT GetClipMetadata(IBlackmagicRawClip* clip, ExrMetadata& metadata)
{
	HRESULT result = S_OK;

	do
	{
		result = clip->GetFrameRate(&metadata.frameRate);
		if (FAILED(result))
		{
			SetError("Failed to get frameRate metadata");
			break;
		}

	} while (0);

	return result;
}

static HRESULT ProcessBrawFile(IBlackmagicRaw* codec, const std::string brawFilename)
{
	IBlackmagicRawClip* clip = nullptr;
	std::string prefix = s_exrFilePrefix;
	std::string folder;
	uint64_t startFrameIndex = 0;
	uint64_t frameCount = 1;
	ExrMetadata metadata;
	std::filesystem::path path = brawFilename;

	do
	{
		std::error_code ec;
		HRESULT result;

		ClearErrors();
		folder = s_exrFolder;
		if (! s_singleFrameOnly)
		{
			folder.append(path.stem());
			folder.append("/");
		}
		if (! std::filesystem::exists(folder,ec))
		{
			std::error_code ec;

			if (! std::filesystem::create_directory(folder, ec))
			{
				std::string msg;
				msg.append("Failed to create folder '");
				msg.append(folder);
				msg.append("' for clip ");
				msg.append(brawFilename);
				SetError(msg.c_str());
				break;
			}
		}
		if (prefix.length() == 0)
			prefix = path.stem();
		s_framesDecodedCount = 0;
		s_framesDecodingCount = 0;
		s_framesMissingCount = 0;

		std::string clipFilename = s_brawFolder + brawFilename;

		result = codec->OpenClip(clipFilename.c_str(), &clip);
		if (FAILED(result))
		{
			SetError("Failed to open IBlackmagicRawClip!");
			break;
		}

		result = SetDecodeOptions(clip);
		if (FAILED(result))
			break;

		result = clip->GetFrameCount(&frameCount);
		if (FAILED(result))
		{
			SetError("Failed to get clip frame count!");
			break;
		}

		result = GetClipMetadata(clip, metadata);
		if (FAILED(result))
		{
			SetError("Failed to get clip metadata!");
			break;
		}

		if (s_singleFrameOnly)
		{
			startFrameIndex = s_singleFrameIndex;
			if (startFrameIndex >= frameCount)
			{
				std::string msg;
				msg.append("Invalid frame ");
				msg.append(std::to_string(startFrameIndex));
				msg.append(" specified to decode. ");
				msg.append("Must be in range [0, ");
				msg.append(std::to_string(frameCount-1));
				msg.append("]");
				SetError(msg.c_str());
				break;
			}
			frameCount = 1;
		}
		ShowFeedbackProgress(brawFilename, frameCount);

		// Decode the frames
		int64_t endFrameIndex = startFrameIndex + frameCount - 1;
		int64_t frameIndex = startFrameIndex;

		while (frameIndex <= endFrameIndex)
		{
			if (s_framesDecodingCount < kMaxdecodeFramesInFlight)
			{
				DecodeFrame(clip, folder, prefix, frameIndex, metadata);
				frameIndex++;
			}
			else
			{
				if (s_framesDecodedCount < frameCount)
					WaitForFrameDecodedOrError();
				ShowFeedbackProgress(brawFilename, frameCount);
			}
			if (s_error)
				break;
		}
		if (s_error)
			break;

		// Wait until all frames are decoded
		bool framesStillDecoding = s_framesDecodedCount < frameCount;

		while (framesStillDecoding)
		{
			if (s_framesDecodedCount < frameCount)
				WaitForFrameDecodedOrError();
			else
				framesStillDecoding = false;
			ShowFeedbackProgress(brawFilename, frameCount);
			if (s_error)
				break;
		}

	} while(0);

	// Clear the buffers used for this clip
	for (uint32_t i = 0; i < kMaxdecodeFramesInFlight; i++)
		s_decodeBuffers[i].clearPixelBuffer();

	// Transcoding of file complete
	s_filesTranscodedCount++;
	ShowFeedbackResult(brawFilename, frameCount);
	if (clip != nullptr)
		clip->Release();

	return S_OK;
}

IBlackmagicRawFactory* CreateFactory()
{
	IBlackmagicRawFactory* factory = nullptr;

	factory = CreateBlackmagicRawFactoryInstance();
	if (factory == nullptr)
		factory = CreateBlackmagicRawFactoryInstanceFromPath("../../Libraries");

		return factory;
}

int main(int argc, const char* argv[])
{
	// Ensure output is not buffered so feedback shows
	setvbuf (stdout, NULL, _IONBF, BUFSIZ);

	// Process the command line arguments
	bool showCompressionOptions = false;

	if (! ProcessCommandLine(argc, argv, showCompressionOptions))
	{
		if (showCompressionOptions)
		{
			PrintCompressionOptions();
		}
		else
		{
			PrintErrors();
			PrintUsage();
		}
		return 1;
	}

	// Mark the decode buffers as not in use
	for (uint32_t i = 0; i < kMaxdecodeFramesInFlight; i++)
		s_decodeBuffers[i].inUse = false;

	// Create factory and codec and process the braw files
	HRESULT result = S_OK;
	IBlackmagicRawFactory* factory = nullptr;
	IBlackmagicRawConfiguration* config = nullptr;
	BlackmagicRawPipeline pipeline;
	void* pipelineContext = nullptr;
	void* pipelineCommandQueue = nullptr;
	IBlackmagicRaw* codec = nullptr;
	CameraCodecCallback callback;
	int filesWithErrorsCount = 0;
	int consecutiveFilesWithErrorsCount = 0;

	do
	{
		factory = CreateFactory();
		if (factory == nullptr)
		{
			SetError("Failed to create IBlackmagicRawFactory!");
			break;
		}

		result = factory->CreateCodec(&codec);
		if (FAILED(result))
		{
			SetError("Failed to create IBlackmagicRaw!");
			break;
		}

		result = codec->QueryInterface(IID_IBlackmagicRawConfiguration, (void**)&config);
		if (FAILED(result))
		{
			SetError("Failed to get IBlackmagicRawConfiguration!");
			break;
		}
		result = config->GetPipeline(&pipeline, &pipelineContext, &pipelineCommandQueue);
		if (FAILED(result))
		{
			SetError("Failed to get pipeline parameters!");
			break;
		}
		config->Release();
		config = nullptr;

		result = codec->SetCallback(&callback);
		if (FAILED(result))
		{
			SetError("Failed to set IBlackmagicRawCallback!");
			break;
		}

		if (! s_quiet)
			printf("Transcoding %lu file%s from folder %s\n", s_brawFiles.size(), s_brawFiles.size()== 1 ? "" : "s", s_brawFolder.c_str());
		for (const auto& filename : s_brawFiles)
		{
			ClearErrors();
			result = codec->PreparePipeline(pipeline, pipelineContext, pipelineCommandQueue, nullptr);
			if (FAILED(result))
				SetError("Failed to clear cached resources");
			else
				ProcessBrawFile(codec, filename);
			if (s_error)
			{
				filesWithErrorsCount++;
				consecutiveFilesWithErrorsCount++;
				PrintErrors();
				ClearErrors();
				if (consecutiveFilesWithErrorsCount >= 3)
				{
					printf("Transcoding aborted due to error count\n");
					break;
				}
			}
			else
			{
				consecutiveFilesWithErrorsCount = 0;
			}
		}

	} while(0);

	PrintErrors();

	if (codec != nullptr)
		codec->FlushJobs();
	if (codec != nullptr)
		codec->Release();
	if (config != nullptr)
		config->Release();
	if (factory != nullptr)
		factory->Release();

	return (s_error || filesWithErrorsCount) ? 1 : 0;
}

