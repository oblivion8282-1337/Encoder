/* -LICENSE-START-
 ** Copyright (c) 2018 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

#include "BlackmagicRawAPI.h"

#include <stdio.h>
#include <iostream>

#ifdef DEBUG
	#include <cassert>
	#define VERIFY(condition) assert(SUCCEEDED(condition))
#else
	#define VERIFY(condition) condition
#endif

static const char* const s_outputFileName = "outputAudio.wav";

typedef struct
{
	// RIFF Header
	char 		riffHeader[4] = { 'R', 'I', 'F', 'F' };
	uint32_t	wavContentSize = 0;

	// WAVE Header
	char		waveHeader[4] = { 'W', 'A', 'V', 'E' };
	char		fmtHeader[4] = { 'f', 'm', 't', ' ' };
	uint32_t	fmtChunkSize = 16; // 16 for PCM
	uint16_t	audioFormat = 1; // PCM
	uint16_t	channelCount = 0;
	uint32_t	sampleRate = 0;
	uint32_t	bytesPerSecond = 0;
	uint16_t	sampleAlignmentBytes = 0; // bytes between samples from the same channel (stride)
	uint16_t	bitDepth = 0;

	// Data Header
	char		dataHeader[4] = { 'd', 'a', 't', 'a' };
	uint32_t	dataBytes = 0;
} tWavFileHeader;

HRESULT OutputWav(IBlackmagicRawClipAudio* audio)
{
	HRESULT result = S_OK;

	uint64_t audioSamples;
	uint32_t bitDepth;
	uint32_t channelCount;
	uint32_t sampleRate;

	result = audio->GetAudioSampleCount(&audioSamples);
	if (result != S_OK)
	{
		std::cerr << "Failed to get Audio Sample Count!" << std::endl;
		return result;
	}

	result = audio->GetAudioBitDepth(&bitDepth);
	if (result != S_OK)
	{
		std::cerr << "Failed to get Audio Bit Depth!" << std::endl;
		return result;
	}

	result = audio->GetAudioChannelCount(&channelCount);
	if (result != S_OK)
	{
		std::cerr << "Failed to get Audio Channel Count!" << std::endl;
		return result;
	}

	result = audio->GetAudioSampleRate(&sampleRate);
	if (result != S_OK)
	{
		std::cerr << "Failed to get Audio Sample Rate!" << std::endl;
		return result;
	}

	tWavFileHeader wavFileHeader;

	wavFileHeader.channelCount = channelCount;
	wavFileHeader.sampleRate = sampleRate;
	wavFileHeader.bytesPerSecond = sampleRate * bitDepth * channelCount / 8;
	wavFileHeader.sampleAlignmentBytes = (bitDepth * channelCount) / 8;
	wavFileHeader.bitDepth = bitDepth;

	uint64_t dataBytes = (audioSamples * channelCount * bitDepth) / 8;
	wavFileHeader.dataBytes = (uint32_t)dataBytes;

	// Size of the data including and following WAVE header
	uint32_t wavContentSize = 36 + (uint32_t)dataBytes;
	wavFileHeader.wavContentSize = wavContentSize;

	remove(s_outputFileName);
	FILE* fileOut = fopen(s_outputFileName, "wb");
	if (fileOut == nullptr)
		return E_FAIL;

	fwrite(&wavFileHeader, sizeof(tWavFileHeader), 1, fileOut);

	static constexpr uint32_t maxSampleCount = 48000;
	uint32_t sampleBufferSize = (maxSampleCount*channelCount*bitDepth)/8;
	int8_t* samples = new int8_t[sampleBufferSize];

	uint32_t audioSampleIndex = 0;
	while (result == S_OK && (audioSampleIndex < audioSamples))
	{
		uint32_t samplesRead;
		uint32_t bytesRead;

		result = audio->GetAudioSamples(audioSampleIndex,
									samples,
									sampleBufferSize,
									maxSampleCount,
									&samplesRead,
									&bytesRead);

		if (result == S_OK)
		{
			fwrite(samples, bytesRead, 1, fileOut);
			audioSampleIndex += samplesRead;
		}

		if (samplesRead == 0)
			break;
	}

	delete[] samples;
	fclose(fileOut);

	return result;
}

int main(int argc, const char* argv[])
{
	if (argc > 2)
	{
		std::cerr << "Usage: " << argv[0] << " clipName.braw" << std::endl;
		return 1;
	}

	const char* clipName = nullptr;
	bool clipNameProvided = argc == 2;
	if (clipNameProvided)
	{
		clipName = argv[1];
	}
	else
	{
		clipName = "../../../Media/sample.braw";
	}

	HRESULT result = S_OK;

	IBlackmagicRawFactory* factory = nullptr;
	IBlackmagicRaw* codec = nullptr;
	IBlackmagicRawClip* clip = nullptr;
	IBlackmagicRawClipAudio* audio = nullptr;

	do
	{
		factory = CreateBlackmagicRawFactoryInstanceFromPath("../../Libraries/");
		if (factory == nullptr)
		{
			std::cerr << "Failed to create IBlackmagicRawFactory!" << std::endl;
			break;
		}

		result = factory->CreateCodec(&codec);
		if (result != S_OK)
		{
			std::cerr << "Failed to create IBlackmagicRaw!" << std::endl;
			break;
		}

		result = codec->OpenClip(clipName, &clip);
		if (result != S_OK)
		{
			std::cerr << "Failed to open IBlackmagicRawClip!" << std::endl;
			break;
		}

		result = clip->QueryInterface(IID_IBlackmagicRawClipAudio, (void**)&audio);
		if (result != S_OK)
		{
			std::cerr << "Failed to get IBlackmagicRawClipAudio!" << std::endl;
			break;
		}

		result = OutputWav(audio);

	} while(0);

	if (audio != nullptr)
		audio->Release();

	if (clip != nullptr)
		clip->Release();

	if (codec != nullptr)
		codec->Release();

	if (factory != nullptr)
		factory->Release();

	return result;
}
