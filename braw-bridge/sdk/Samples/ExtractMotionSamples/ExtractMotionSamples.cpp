/* -LICENSE-START-
 ** Copyright (c) 2018 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

#include "BlackmagicRawAPI.h"

#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>

#ifdef DEBUG
	#include <cassert>
	#define VERIFY(condition) assert(SUCCEEDED(condition))
#else
	#define VERIFY(condition) condition
#endif

std::string GenerateTimecode(IBlackmagicRawClip* clip, uint64_t motionSampleIndex, float motionSampleRate, float videoFrameRate)
{
	const float videoFrameIndexFloat = (float(motionSampleIndex) / motionSampleRate) * videoFrameRate;
	const uint32_t videoFrameIndex = uint32_t(videoFrameIndexFloat);
	const float videoFrameIndexFractionalPart = videoFrameIndexFloat - float(videoFrameIndex);
	std::string timecodeString = "00:00:00:00.000";
	const char* timecodeCString;

	const HRESULT result = clip->GetTimecodeForFrame(videoFrameIndex, &timecodeCString);

	if (result == S_OK)
	{
		timecodeString = timecodeCString;

		free((void*)timecodeCString);

		std::ostringstream timecodeStream;

		timecodeStream << timecodeString;
		timecodeStream << ".";
		timecodeStream << std::setw(3) << std::setfill('0') << uint32_t(videoFrameIndexFractionalPart * 1000);
		timecodeString = timecodeStream.str();
	}

	return timecodeString;
}

HRESULT OutputCsv(IBlackmagicRawClip* clip, IBlackmagicRawClipAccelerometerMotion* accelerometerMotion, IBlackmagicRawClipGyroscopeMotion* gyroscopeMotion, const std::string& outputFileName)
{
	HRESULT result = S_OK;

	float videoFrameRate;
	
	result = clip->GetFrameRate(&videoFrameRate);

	if (result != S_OK)
	{
		std::cerr << "Failed to get video frame rate!" << std::endl;
		return result;
	}

	float accelerometerMotionSampleRate = 0.0f;
	uint32_t accelerometerMotionSampleCount = 0;
	uint32_t accelerometerMotionSampleSizeInFloats = 0;

	result = accelerometerMotion->GetSampleRate(&accelerometerMotionSampleRate);

	if (result != S_OK)
	{
		std::cerr << "Failed to get accelerometer sample rate!" << std::endl;
		return result;
	}

	result = accelerometerMotion->GetSampleCount(&accelerometerMotionSampleCount);

	if (result != S_OK)
	{
		std::cerr << "Failed to get accelerometer sample count!" << std::endl;
		return result;
	}

	result = accelerometerMotion->GetSampleSize(&accelerometerMotionSampleSizeInFloats);

	if (result != S_OK)
	{
		std::cerr << "Failed to get accelerometer sample size!" << std::endl;
		return result;
	}

	float gyroscopeMotionSampleRate = 0.0f;
	uint32_t gyroscopeMotionSampleCount = 0;
	uint32_t gyroscopeMotionSampleSizeInFloats = 0;

	result = gyroscopeMotion->GetSampleRate(&gyroscopeMotionSampleRate);

	if (result != S_OK)
	{
		std::cerr << "Failed to get gyroscope sample rate!" << std::endl;
		return result;
	}

	result = gyroscopeMotion->GetSampleCount(&gyroscopeMotionSampleCount);

	if (result != S_OK)
	{
		std::cerr << "Failed to get gyroscope sample count!" << std::endl;
		return result;
	}

	result = gyroscopeMotion->GetSampleSize(&gyroscopeMotionSampleSizeInFloats);

	if (result != S_OK)
	{
		std::cerr << "Failed to get gyroscope sample size!" << std::endl;
		return result;
	}

	if (gyroscopeMotionSampleRate != accelerometerMotionSampleRate)
	{
		std::cerr << "Gyroscope and accelerometer sample rates must be equal!" << std::endl;
		return E_FAIL;
	}

	if (gyroscopeMotionSampleSizeInFloats != 3)
	{
		std::cerr << "Unsupported gyroscope sample size!" << std::endl;
		return E_FAIL;
	}

	if (accelerometerMotionSampleSizeInFloats != 3)
	{
		std::cerr << "Unsupported accelerometer sample size!" << std::endl;
		return E_FAIL;
	}

	remove(outputFileName.c_str());

	std::ofstream fileOut(outputFileName);

	if (! fileOut)
	{
		return E_FAIL;
	}

	fileOut << "Timecode,              Accel_x,          Accel_y,          Accel_z,          Gyro_x,           Gyro_y,           Gyro_z," << std::endl;

	const uint32_t motionSampleSizeInFloats = gyroscopeMotionSampleSizeInFloats;
	const float motionSampleRate = gyroscopeMotionSampleRate;
	const uint32_t kMotionSampleBufferSizeInSamples = 2000;
	const uint32_t motionSampleBufferSizeInFloats = (motionSampleSizeInFloats * kMotionSampleBufferSizeInSamples);
	float* const accelerometerMotionSamples = new float[motionSampleBufferSizeInFloats];
	float* const gyroscopeMotionSamples = new float[motionSampleBufferSizeInFloats];
	uint64_t motionSampleBaseIndex = 0;
	uint32_t motionSamplesRemaining = std::min(accelerometerMotionSampleCount, gyroscopeMotionSampleCount);

	for (;;)
	{
		const uint32_t motionSamplesToRead = std::min(kMotionSampleBufferSizeInSamples, motionSamplesRemaining);

		uint32_t accelerometerMotionSamplesRead = 0;

		result = accelerometerMotion->GetSampleRange(motionSampleBaseIndex,
													 motionSamplesToRead,
													 accelerometerMotionSamples,
													 &accelerometerMotionSamplesRead);

		if (result != S_OK)
		{
			break;
		}
		
		uint32_t gyroscopeMotionSamplesRead = 0;

		result = gyroscopeMotion->GetSampleRange(motionSampleBaseIndex,
												 motionSamplesToRead,
												 gyroscopeMotionSamples,
												 &gyroscopeMotionSamplesRead);

		if (result != S_OK)
		{
			break;
		}

		const uint32_t motionSamplesRead = std::min(accelerometerMotionSamplesRead, gyroscopeMotionSamplesRead);

		for (uint32_t bufferIndexInSamples = 0; bufferIndexInSamples < motionSamplesRead; bufferIndexInSamples++)
		{
			const uint64_t motionSampleIndex = motionSampleBaseIndex + bufferIndexInSamples;

			const std::string timecode = GenerateTimecode(clip, motionSampleIndex, motionSampleRate, videoFrameRate);

			const uint64_t bufferIndexInFloats = bufferIndexInSamples * motionSampleSizeInFloats;

			fileOut																				<<
				timecode << ", "																<<
				std::fixed << std::setprecision(8)												<<
				std::setw(16) << accelerometerMotionSamples[bufferIndexInFloats + 0] << ", "	<<
				std::setw(16) << accelerometerMotionSamples[bufferIndexInFloats + 1] << ", "	<<
				std::setw(16) << accelerometerMotionSamples[bufferIndexInFloats + 2] << ", "	<<
				std::setw(16) << gyroscopeMotionSamples[bufferIndexInFloats + 0] << ", "		<<
				std::setw(16) << gyroscopeMotionSamples[bufferIndexInFloats + 1] << ", "		<<
				std::setw(16) << gyroscopeMotionSamples[bufferIndexInFloats + 2] << ","			<<
				std::endl;
		}

		motionSampleBaseIndex += motionSamplesRead;
		motionSamplesRemaining -= motionSamplesRead;

		if (motionSamplesRemaining == 0)
		{
			break;
		}
	}

	delete[] gyroscopeMotionSamples;
	delete[] accelerometerMotionSamples;
	fileOut.close();

	return result;
}

int main(int argc, const char* argv[])
{
	const std::string defaultOutputFileName = "outputMotionSamples.csv";

	if ((argc < 2) || (argc > 3))
	{
		std::cerr << "Usage: " << argv[0] << " clipName.braw [outputFileName.csv (defaults to " << defaultOutputFileName << ")]" << std::endl;
		return 1;
	}

	std::string clipName = argv[1];

	std::string outputFileName;
	const bool outputFileNameProvided = (argc > 2);

	if (outputFileNameProvided)
	{
		outputFileName = argv[2];
	}
	else
	{
		outputFileName = defaultOutputFileName;
	}

	std::cout << "Outputting motion samples from " << clipName <<  " to " << outputFileName << "..." << std::endl;

	HRESULT result = S_OK;

	IBlackmagicRawFactory* factory = nullptr;
	IBlackmagicRaw* codec = nullptr;
	IBlackmagicRawClip* clip = nullptr;
	IBlackmagicRawClipAccelerometerMotion* accelerometerMotion = nullptr;
	IBlackmagicRawClipGyroscopeMotion* gyroscopeMotion = nullptr;

	do
	{
		factory = CreateBlackmagicRawFactoryInstanceFromPath("../../Libraries");
		
		if (factory == nullptr)
		{
			std::cerr << "Failed to create IBlackmagicRawFactory!" << std::endl;
			break;
		}

		result = factory->CreateCodec(&codec);

		if (result != S_OK)
		{
			std::cerr << "Failed to create IBlackmagicRaw!" << std::endl;
			break;
		}

		result = codec->OpenClip(clipName.c_str(), &clip);

		if (result != S_OK)
		{
			std::cerr << "Failed to open IBlackmagicRawClip!" << std::endl;
			break;
		}

		result = clip->QueryInterface(IID_IBlackmagicRawClipAccelerometerMotion, (void**)&accelerometerMotion);

		if (result != S_OK)
		{
			std::cerr << "Failed to get IBlackmagicRawAccelerometerMotion!" << std::endl;
			break;
		}

		result = clip->QueryInterface(IID_IBlackmagicRawClipGyroscopeMotion, (void**)&gyroscopeMotion);

		if (result != S_OK)
		{
			std::cerr << "Failed to get IBlackmagicRawGyroscopeMotion!" << std::endl;
			break;
		}

		result = OutputCsv(clip, accelerometerMotion, gyroscopeMotion, outputFileName);
	}
	while(0);

	if (gyroscopeMotion != nullptr)
	{
		gyroscopeMotion->Release();
	}

	if (accelerometerMotion != nullptr)
	{
		accelerometerMotion->Release();
	}

	if (clip != nullptr)
	{
		clip->Release();
	}

	if (codec != nullptr)
	{
		codec->Release();
	}

	if (factory != nullptr)
	{
		factory->Release();
	}

	return result;
}
