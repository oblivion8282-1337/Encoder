/* -LICENSE-START-
 ** Copyright (c) 2018 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

#include "BlackmagicRawAPI.h"

#include "cuda.h"
#include "cuda_runtime_api.h"

#include <atomic>
#include <chrono>
#include <iostream>
#include <thread>

#ifdef DEBUG
	#include <cassert>
	#define VERIFY(condition) assert(SUCCEEDED(condition))
#else
	#define VERIFY(condition) condition
#endif

static const BlackmagicRawResourceFormat s_resourceFormat = blackmagicRawResourceFormatRGBAU8;
static const int s_maxJobsInFlight = 3;
static std::atomic<int> s_jobsInFlight = {0};

struct UserData
{
	unsigned long long frameIndex;
};

class CameraCodecCallback : public IBlackmagicRawCallback
{
public:
	explicit CameraCodecCallback() = default;
	virtual ~CameraCodecCallback() = default;

	virtual void ReadComplete(IBlackmagicRawJob* readJob, HRESULT result, IBlackmagicRawFrame* frame)
	{
		UserData* userData = nullptr;
		VERIFY(readJob->GetUserData((void**)&userData));

		IBlackmagicRawJob* decodeAndProcessJob = nullptr;

		if (result == S_OK)
			VERIFY(frame->SetResourceFormat(s_resourceFormat));

		if (result == S_OK)
			result = frame->CreateJobDecodeAndProcessFrame(nullptr, nullptr, &decodeAndProcessJob);

		if (result == S_OK)
			VERIFY(decodeAndProcessJob->SetUserData(userData));

		if (result == S_OK)
			result = decodeAndProcessJob->Submit();

		if (result != S_OK)
		{
			if (decodeAndProcessJob)
				decodeAndProcessJob->Release();

			delete userData;
		}

		readJob->Release();
	}

	virtual void ProcessComplete(IBlackmagicRawJob* job, HRESULT result, IBlackmagicRawProcessedImage*)
	{
		UserData* userData = nullptr;
		VERIFY(job->GetUserData((void**)&userData));

		std::cout << "Processed frame index: " << userData->frameIndex << std::endl;
		delete userData;

		job->Release();
		--s_jobsInFlight;
	}

	virtual void DecodeComplete(IBlackmagicRawJob*, HRESULT) {}
	virtual void TrimProgress(IBlackmagicRawJob*, float) {}
	virtual void TrimComplete(IBlackmagicRawJob*, HRESULT) {}
	virtual void SidecarMetadataParseWarning(IBlackmagicRawClip*, const char*, uint32_t, const char*) {}
	virtual void SidecarMetadataParseError(IBlackmagicRawClip*, const char*, uint32_t, const char*) {}
	virtual void PreparePipelineComplete(void*, HRESULT) {}

	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID*)
	{
		return E_NOTIMPL;
	}

	virtual ULONG STDMETHODCALLTYPE AddRef(void)
	{
		return 0;
	}

	virtual ULONG STDMETHODCALLTYPE Release(void)
	{
		return 0;
	}
};

HRESULT ProcessClip(IBlackmagicRawClip* clip)
{
	HRESULT result;

	long unsigned int frameCount = 0;
	long unsigned int frameIndex = 0;

	result = clip->GetFrameCount(&frameCount);

	while (frameIndex < frameCount)
	{
		if (s_jobsInFlight >= s_maxJobsInFlight)
		{
			std::this_thread::sleep_for(std::chrono::microseconds(100));
			continue;
		}

		IBlackmagicRawJob* jobRead = nullptr;
		if (result == S_OK)
			result = clip->CreateJobReadFrame(frameIndex, &jobRead);

		UserData* userData = nullptr;
		if (result == S_OK)
		{
			userData = new UserData();
			userData->frameIndex = frameIndex;
			VERIFY(jobRead->SetUserData(userData));
		}

		if (result == S_OK)
			result = jobRead->Submit();

		if (result != S_OK)
		{
			if (userData != nullptr)
				delete userData;

			if (jobRead != nullptr)
				jobRead->Release();

			break;
		}

		++s_jobsInFlight;

		frameIndex++;
	}

	return result;
}

int main(int argc, const char* argv[])
{
	if (argc > 2)
	{
		std::cerr << "Usage: " << argv[0] << " clipName.braw" << std::endl;
		return 1;
	}

	const char* clipName = nullptr;
	bool clipNameProvided = argc == 2;
	if (clipNameProvided)
	{
		clipName = argv[1];
	}
	else
	{
		clipName = "../../../Media/sample.braw";
	}

	HRESULT result = S_OK;

	IBlackmagicRawFactory* factory = nullptr;
	IBlackmagicRaw* codec = nullptr;
	IBlackmagicRawClip* clip = nullptr;
	IBlackmagicRawConfiguration* config = nullptr;

	void* context = nullptr;
	void* commandQueue = nullptr;

	CameraCodecCallback callback;

	do
	{
		factory = CreateBlackmagicRawFactoryInstanceFromPath("../../Libraries/");
		if (factory == nullptr)
		{
			std::cerr << "Failed to create IBlackmagicRawFactory!" << std::endl;
			break;
		}

		if (CUDART_VERSION != 10000)
		{
			std::cerr << "Expecting CUDA 10.0!" << std::endl;
			break;
		}

		if (cuInit(0) == CUDA_SUCCESS)
		{
			int deviceCount = 0;
			if (cuDeviceGetCount(&deviceCount) == CUDA_SUCCESS)
			{
				for (int deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex)
				{
					CUcontext cudaContext;
					CUdevice cudaDevice;
					if (cuDeviceGet(&cudaDevice, deviceIndex) == CUDA_SUCCESS)
					{
						char deviceName[256];
						if (cuDeviceGetName(deviceName, 255, cudaDevice) == CUDA_SUCCESS)
						{
							if (cuCtxCreate(&cudaContext, CU_CTX_MAP_HOST | CU_CTX_SCHED_BLOCKING_SYNC, cudaDevice) == CUDA_SUCCESS)
							{
								context = cudaContext;
								commandQueue = nullptr;
							}
						}
					}
				}
			}
		}

		if (context == nullptr)
		{
			result = E_FAIL;
			std::cerr << "Failed to create cuda context!" << std::endl;
			break;
		}

		result = factory->CreateCodec(&codec);
		if (result != S_OK)
		{
			std::cerr << "Failed to create IBlackmagicRaw!" << std::endl;
			break;
		}

		result = codec->QueryInterface(IID_IBlackmagicRawConfiguration, (void**)&config);
		if (result != S_OK)
		{
			std::cerr << "Failed to get IID_IBlackmagicRawConfiguration!" << std::endl;
			break;
		}

		result = config->SetPipeline(blackmagicRawPipelineCUDA, context, commandQueue);
		if (result != S_OK)
		{
			std::cerr << "Failed to set cuda pipeline!" << std::endl;
			break;
		}

		result = codec->OpenClip(clipName, &clip);
		if (result != S_OK)
		{
			std::cerr << "Failed to open IBlackmagicRawClip!" << std::endl;
			break;
		}

		result = codec->SetCallback(&callback);
		if (result != S_OK)
		{
			std::cerr << "Failed to set IBlackmagicRawCallback!" << std::endl;
			break;
		}

		result = ProcessClip(clip);
		codec->FlushJobs();

	} while(0);

	if (config != nullptr)
		config->Release();

	if (clip != nullptr)
		clip->Release();

	if (codec != nullptr)
		codec->Release();

	if (context != nullptr)
		cuCtxDestroy(reinterpret_cast<CUcontext>(context));

	if (factory != nullptr)
		factory->Release();

	return result;
}
