/* -LICENSE-START-
 ** Copyright (c) 2019 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

#include "BlackmagicRawAPI.h"

#include <atomic>
#include <chrono>
#include <iostream>
#include <thread>
#include <array>
#include <cassert>
#include <mutex>

#ifdef NDEBUG
#	define VERIFY(condition) condition
#else
#	define VERIFY(condition) assert(SUCCEEDED(condition))
#endif


// This sample code shows the Manual Decoder pipeline of the the Blackmagic RAW SDK.
// The Manual Decoder splits the Decode and Process operations into two separate steps each with their own callbacks.
// It also gives you far greater control over how buffers are allocated and used, allowing you to optimise the API's performance based on your application's needs.
// Note that this sample uses Flow 1 of the Manual Decoder, meaning that GPU acceleration is not enabled during the Process step.
// That being said, it's more straightforward than the Flow 2 sample.  We recommend you go through this one first.
// Also note that this sample has been written with simplicity in mind.  A real application should be robust in handling errors, such as resource allocations failing.

static constexpr BlackmagicRawResourceFormat s_resourceFormat = blackmagicRawResourceFormatRGBAU8;

// We run two jobs in parallel, to ensure best performance while minimising memory footprint.
static constexpr int s_maxJobsInFlight = 2;
static std::atomic<int> s_jobsInFlight = {0};

class BufferManagerFlow1
{
public:
	BufferManagerFlow1(IBlackmagicRawResourceManager* resourceManager, IBlackmagicRawManualDecoderFlow1* manualDecoder, void* post3DLUTBufferCPU)
	: m_resourceManager(resourceManager)
	, m_manualDecoder(manualDecoder)
	, m_post3DLUTBufferCPU(post3DLUTBufferCPU)
	{
	}
	
	~BufferManagerFlow1()
	{
		for (void* buffer : {m_bitStream, m_frameState, m_decodedBuffer, m_processedBuffer})
		{
			if (buffer != nullptr)
			{
				VERIFY(m_resourceManager->ReleaseResource(nullptr, nullptr, buffer, blackmagicRawResourceTypeBufferCPU));
			}
		}
	}
	
	void populateFrameStateBuffer(IBlackmagicRawFrame* frame)
	{
		uint32_t frameStateSizeBytes;
		VERIFY(m_manualDecoder->GetFrameStateSizeBytes(&frameStateSizeBytes));

		// Allocate the buffer if necessary
		if (frameStateSizeBytes > m_frameStateSizeBytes)
		{
			if (m_frameState != nullptr)
			{
				VERIFY(m_resourceManager->ReleaseResource(nullptr, nullptr, m_frameState, blackmagicRawResourceTypeBufferCPU));
			}
			
			VERIFY(m_resourceManager->CreateResource(nullptr, nullptr, frameStateSizeBytes, blackmagicRawResourceTypeBufferCPU, blackmagicRawResourceUsageReadCPUWriteCPU, &m_frameState));
			m_frameStateSizeBytes = frameStateSizeBytes;
		}
		
		// Populate the buffer
		VERIFY(m_manualDecoder->PopulateFrameStateBuffer(frame, nullptr, nullptr, m_frameState, frameStateSizeBytes));
	}
	
	void createReadJob(IBlackmagicRawClipEx* clipEx, uint64_t frameIndex, IBlackmagicRawJob** jobRead)
	{
		uint32_t bitStreamSizeBytes = 0;
		VERIFY(clipEx->GetBitStreamSizeBytes(frameIndex, &bitStreamSizeBytes));
		
		// Allocate the buffer if necessary
		if (bitStreamSizeBytes > m_bitStreamSizeBytes)
		{
			if (m_bitStream != nullptr)
			{
				VERIFY(m_resourceManager->ReleaseResource(nullptr, nullptr, m_bitStream, blackmagicRawResourceTypeBufferCPU));
			}

			VERIFY(m_resourceManager->CreateResource(nullptr, nullptr, bitStreamSizeBytes, blackmagicRawResourceTypeBufferCPU, blackmagicRawResourceUsageReadCPUWriteCPU, &m_bitStream));
			m_bitStreamSizeBytes = bitStreamSizeBytes;
		}
		
		// Create the job
		VERIFY(clipEx->CreateJobReadFrame(frameIndex, m_bitStream, bitStreamSizeBytes, jobRead));
	}
	
	void createDecodeJob(IBlackmagicRawJob** decodeJob)
	{
		uint32_t decodedBufferSizeBytes;
		VERIFY(m_manualDecoder->GetDecodedSizeBytes(m_frameState, &decodedBufferSizeBytes));
		
		// Allocate the buffer if necessary
		if (decodedBufferSizeBytes > m_decodedBufferSizeBytes)
		{
			if (m_decodedBuffer != nullptr)
			{
				VERIFY(m_resourceManager->ReleaseResource(nullptr, nullptr, m_decodedBuffer, blackmagicRawResourceTypeBufferCPU));
			}

			VERIFY(m_resourceManager->CreateResource(nullptr, nullptr, decodedBufferSizeBytes, blackmagicRawResourceTypeBufferCPU, blackmagicRawResourceUsageReadCPUWriteCPU, &m_decodedBuffer));
			m_decodedBufferSizeBytes = decodedBufferSizeBytes;
		}
		
		// Create the job
		VERIFY(m_manualDecoder->CreateJobDecode(m_frameState, m_bitStream, m_decodedBuffer, decodeJob));
	}
	
	void createProcessJob(IBlackmagicRawJob** processJob)
	{
		uint32_t processedBufferSizeBytes;
		VERIFY(m_manualDecoder->GetProcessedSizeBytes(m_frameState, &processedBufferSizeBytes));
		
		// Allocate the buffer if necessary
		if (processedBufferSizeBytes > m_processedBufferSizeBytes)
		{
			if (m_processedBuffer != nullptr)
			{
				VERIFY(m_resourceManager->ReleaseResource(nullptr, nullptr, m_processedBuffer, blackmagicRawResourceTypeBufferCPU));
			}

			VERIFY(m_resourceManager->CreateResource(nullptr, nullptr, processedBufferSizeBytes, blackmagicRawResourceTypeBufferCPU, blackmagicRawResourceUsageReadCPUWriteCPU, &m_processedBuffer));
			m_processedBufferSizeBytes = processedBufferSizeBytes;
		}
		
		// Create the job
		VERIFY(m_manualDecoder->CreateJobProcess(m_frameState, m_decodedBuffer, m_processedBuffer, m_post3DLUTBufferCPU, processJob));
	}

private:
	IBlackmagicRawResourceManager*		m_resourceManager			= nullptr;
	IBlackmagicRawManualDecoderFlow1*	m_manualDecoder				= nullptr;
	void* m_post3DLUTBufferCPU										= nullptr;

	uint32_t							m_bitStreamSizeBytes		= 0;
	void*								m_bitStream					= nullptr;

	uint32_t							m_frameStateSizeBytes		= 0;
	void*								m_frameState				= nullptr;
	
	uint32_t							m_decodedBufferSizeBytes	= 0;
	void*								m_decodedBuffer				= nullptr;

	uint32_t							m_processedBufferSizeBytes	= 0;
	void*								m_processedBuffer			= nullptr;
};

struct UserData
{
	unsigned long long m_frameIndex;
	BufferManagerFlow1* m_bufferManager;
};

class CameraCodecCallback : public IBlackmagicRawCallback
{
public:
    explicit CameraCodecCallback() = default;
    virtual ~CameraCodecCallback() = default;
    
    virtual void ReadComplete(IBlackmagicRawJob* readJob, HRESULT result, IBlackmagicRawFrame* frame)
    {
        UserData* userData = nullptr;
        VERIFY(readJob->GetUserData((void**)&userData));
		BufferManagerFlow1* bufferManager = userData->m_bufferManager;

		if (SUCCEEDED(result))
		{
			std::lock_guard<std::mutex> lock(m_mutex);
			std::cout << "Read frame index: " << userData->m_frameIndex << std::endl;
		}
		else
		{
			std::lock_guard<std::mutex> lock(m_mutex);
			std::cout << "Failed to read frame index: " << userData->m_frameIndex << std::endl;
			
			delete userData;
			s_jobsInFlight--;
			return;
		}

		// Set the Resource Format before populating the Frame State buffer
        VERIFY(frame->SetResourceFormat(s_resourceFormat));
		
		// Allocate and populate the Frame State Buffer
		bufferManager->populateFrameStateBuffer(frame);
		
		// Start the Decode job
		IBlackmagicRawJob* decodeJob = nullptr;
		bufferManager->createDecodeJob(&decodeJob);
		VERIFY(decodeJob->SetUserData(userData));
		VERIFY(decodeJob->Submit());

		// Release the job (The API holds a reference to the job, so this call is just transferring ownership)
		VERIFY(decodeJob->Release());
    }
    
    virtual void DecodeComplete(IBlackmagicRawJob* decodeJob, HRESULT result)
    {
        UserData* userData = nullptr;
        VERIFY(decodeJob->GetUserData((void**)&userData));
		BufferManagerFlow1* bufferManager = userData->m_bufferManager;

		if (SUCCEEDED(result))
		{
			std::lock_guard<std::mutex> lock(m_mutex);
			std::cout << "Decoded frame index: " << userData->m_frameIndex << std::endl;
		}
		else
		{
			std::lock_guard<std::mutex> lock(m_mutex);
			std::cout << "Failed to decode frame index: " << userData->m_frameIndex << std::endl;
			
			delete userData;
			s_jobsInFlight--;
			return;
		}
		
		// Start the Process job
		IBlackmagicRawJob* processJob = nullptr;
		bufferManager->createProcessJob(&processJob);
        VERIFY(processJob->SetUserData(userData));
        VERIFY(processJob->Submit());
        
		// Release the job (The API holds a reference to the job, so this call is just transferring ownership)
        VERIFY(processJob->Release());
    }
    
    virtual void ProcessComplete(IBlackmagicRawJob* processJob, HRESULT result, IBlackmagicRawProcessedImage*)
    {
        UserData* userData = nullptr;
        VERIFY(processJob->GetUserData((void**)&userData));
		
		if (SUCCEEDED(result))
		{
			std::lock_guard<std::mutex> lock(m_mutex);
			std::cout << "Processed frame index: " << userData->m_frameIndex << std::endl;
		}
		else
		{
			std::lock_guard<std::mutex> lock(m_mutex);
			std::cout << "Faled to process frame index: " << userData->m_frameIndex << std::endl;
		}
		
		delete userData;
        s_jobsInFlight--;
    }
    
    virtual void TrimProgress(IBlackmagicRawJob*, float) {}
    virtual void TrimComplete(IBlackmagicRawJob*, HRESULT) {}
	virtual void SidecarMetadataParseWarning(IBlackmagicRawClip*, const char*, uint32_t, const char*) {}
	virtual void SidecarMetadataParseError(IBlackmagicRawClip*, const char*, uint32_t, const char*) {}
	virtual void PreparePipelineComplete(void*, HRESULT) {}

    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID*)
    {
        return E_NOTIMPL;
    }
    
    virtual ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return 0;
    }
    
    virtual ULONG STDMETHODCALLTYPE Release(void)
    {
        return 0;
    }
	
private:
	std::mutex m_mutex;
};

HRESULT ProcessClipManual(CameraCodecCallback* callback, IBlackmagicRawClip* clip, IBlackmagicRawResourceManager* resourceManager, IBlackmagicRawManualDecoderFlow1* manualDecoder)
{
    IBlackmagicRawClipProcessingAttributes* clipProcessingAttributes = nullptr;
    IBlackmagicRawPost3DLUT* clipPost3DLUT = nullptr;
    IBlackmagicRawClipEx* clipEx = nullptr;

	void* clipPost3DLUTBufferCPU = nullptr;
    uint64_t frameCount = 0;
	uint64_t frameIndex = 0;

    VERIFY(clip->QueryInterface(IID_IBlackmagicRawClipEx, (void**)&clipEx));
    VERIFY(clip->QueryInterface(IID_IBlackmagicRawClipProcessingAttributes, (void**)&clipProcessingAttributes));
    VERIFY(clip->GetFrameCount(&frameCount));
    VERIFY(clipProcessingAttributes->GetPost3DLUT(&clipPost3DLUT));
	if (clipPost3DLUT != nullptr)
	{
		// This buffer is owned by the IBlackmagicRawPost3DLUT object
		VERIFY(clipPost3DLUT->GetResourceCPU(&clipPost3DLUTBufferCPU));
	}

	// We re-use BufferManager objects to avoid reallocating buffers every frame
	std::array<BufferManagerFlow1*, s_maxJobsInFlight> bufferManagerPool;
	for (int i = 0; i < bufferManagerPool.size(); i++)
	{
		bufferManagerPool[i] = new BufferManagerFlow1(resourceManager, manualDecoder, clipPost3DLUTBufferCPU);
	}

	while (frameIndex < frameCount)
    {
		// Spin while the pipeline is saturated
        if (s_jobsInFlight >= s_maxJobsInFlight)
        {
            std::this_thread::sleep_for(std::chrono::microseconds(100));
            continue;
        }
		
		BufferManagerFlow1* bufferManager = bufferManagerPool[frameIndex % s_maxJobsInFlight];
		
		IBlackmagicRawJob* jobRead;
		bufferManager->createReadJob(clipEx, frameIndex, &jobRead);
		
		// Allocate and populate the UserData struct
        UserData* userData = new UserData();
		userData->m_bufferManager = bufferManager;
        userData->m_frameIndex = frameIndex;
        VERIFY(jobRead->SetUserData(userData));
        
        // Start the Read job
        VERIFY(jobRead->Submit());
		s_jobsInFlight++;

		// Release the job (The API holds a reference to the job, so this call is just transferring ownership)
        VERIFY(jobRead->Release());
		
		frameIndex++;
	}
	
	// Wait for all jobs to be complete before cleaning up.
	while (s_jobsInFlight > 0)
	{
		std::this_thread::sleep_for(std::chrono::microseconds(100));
	}

	for (int i = 0; i < bufferManagerPool.size(); i++)
	{
		delete bufferManagerPool[i];
	}

    if (clipPost3DLUT != nullptr)
        clipPost3DLUT->Release();
	
	if (clipProcessingAttributes != nullptr)
		clipProcessingAttributes->Release();
	
	if (clipEx != nullptr)
    	clipEx->Release();
    
    return S_OK;
}

int main(int argc, const char* argv[])
{
    if (argc > 2)
    {
        std::cerr << "Usage: " << argv[0] << " clipName.braw" << std::endl;
        return 1;
    }
    
	const char* clipName = nullptr;
	bool clipNameProvided = argc == 2;
	if (clipNameProvided)
	{
		clipName = argv[1];
	}
	else
	{
		clipName = "../../../Media/sample.braw";
	}
    
    HRESULT result = S_OK;
    
    IBlackmagicRawFactory* factory = nullptr;
	IBlackmagicRaw* codec = nullptr;
	IBlackmagicRawConfigurationEx* configurationEx = nullptr;
	IBlackmagicRawResourceManager* resourceManager = nullptr;
	IBlackmagicRawManualDecoderFlow1* manualDecoder = nullptr;
    IBlackmagicRawClip* clip = nullptr;

    CameraCodecCallback callback;
    
    do
    {
		factory = CreateBlackmagicRawFactoryInstanceFromPath("../../Libraries/");
		if (factory == nullptr)
		{
			std::cerr << "Failed to create IBlackmagicRawFactory!" << std::endl;
			break;
		}
        
        result = factory->CreateCodec(&codec);
        if (result != S_OK)
        {
            std::cerr << "Failed to create IBlackmagicRaw!" << std::endl;
            break;
        }
        
        result = codec->QueryInterface(IID_IBlackmagicRawConfigurationEx, (void**)&configurationEx);
        if (result != S_OK)
        {
            std::cerr << "Failed to get IBlackmagicRawConfigurationEx!" << std::endl;
            break;
        }
        
        result = configurationEx->GetResourceManager(&resourceManager);
        if (result != S_OK)
        {
            std::cerr << "Failed to get IBlackmagicRawResourceManager!" << std::endl;
            break;
        }
        
        result = codec->QueryInterface(IID_IBlackmagicRawManualDecoderFlow1, (void**)&manualDecoder);
        if (result != S_OK)
        {
            std::cerr << "Failed to get IBlackmagicRaw!" << std::endl;
            break;
        }
        
        result = codec->OpenClip(clipName, &clip);
        if (result != S_OK)
        {
            std::cerr << "Failed to open IBlackmagicRawClip!" << std::endl;
            break;
        }
        
        result = codec->SetCallback(&callback);
        if (result != S_OK)
        {
            std::cerr << "Failed to set IBlackmagicRawCallback!" << std::endl;
            break;
        }
        
        result = ProcessClipManual(&callback, clip, resourceManager, manualDecoder);
        codec->FlushJobs();
        
    } while (0);
	
	if (clip != nullptr)
		clip->Release();

    if (manualDecoder != nullptr)
        manualDecoder->Release();
    
    if (resourceManager != nullptr)
        resourceManager->Release();

    if (configurationEx != nullptr)
        configurationEx->Release();
    
    if (codec != nullptr)
        codec->Release();
    
    if (factory != nullptr)
        factory->Release();
        
    return result;
}
